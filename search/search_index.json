{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>Welcome the documentation for the MINIMOD Optimization Tool!</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#install-with-pip","title":"Install with <code>pip</code>","text":"<p>To install the tool with the Python package manager <code>pip</code>, type:</p> <pre><code>\npip install minimod-opt\n\n</code></pre>"},{"location":"#install-with-source","title":"Install with source","text":"<p>You can also install the tool with source by cloning the repository and then installing with pip:</p> <pre><code>git clone https://github.com/minimod-nutrition/minimod-opt.git\n\ncd minimod-opt\n\npip install .\n\n</code></pre>"},{"location":"base/","title":"Base Classes","text":""},{"location":"base/#minimod_opt.base.model.Model","title":"<code>Model</code>","text":"Source code in <code>minimod_opt/base/model.py</code> <pre><code>class Model:\n\n\n    def __init__(self, data:pd.DataFrame, sense:str, solver_name:str, show_output:bool):\n\"\"\"A class that instantiates a `mip` model.\n\n        Args:\n            data (pd.DataFrame): The input dataframe that includes benefit/cost data\n            sense (str): Whether the model should minimize (MINIMIZE) or maximize (MAXIMIZE)\n            solver_name (str): The solver type (CBC or some other mip solver)\n            show_output (bool):  Whether to show output of model construction\n        \"\"\"\n\n\n        ## Tell the fitter whether to maximize or minimize\n        self.model = mip.Model(sense=sense, solver_name=solver_name)\n\n        self._df = data\n\n        self.show_output = show_output\n\n        if self.show_output:\n            self.model.verbose = 1\n        else:\n            self.model.verbose = 0\n        ## set tolerances based on GAMS tolerances\n        # primal tol -&gt; infeas\n        # dual tol -&gt; opt tol\n        # integer  tol -&gt; integer_tol\n        # self.model.opt_tol = 1e-10\n        # self.model.infeas_tol = 1e-10\n        # self.model.integer_tol = 1e-06\n        # self.model.seed = 0\n        # # self.model.clique = 0\n\n        # # # # # allowable gap/ optca -&gt; max_mip_gap_abs\n        # # # # # ratioGap/ optcr -&gt; max_mip_gap\n\n        # self.model.max_mip_gap_abs = 0\n        # self.model.max_mip_gap = 0.1\n\n        # self.model.preprocess = 0\n        # self.model.lp_method = -1\n        # self.cut_passes = 1\n\n    def _stringify_tuple(self, tup:tuple)-&gt;str:\n\"\"\"This function converts all the items of a tuple into one string\n\n        Args:\n            tup (tuple): general tuple \n\n        Returns:\n            str: output string generated from all items in the tuple\n        \"\"\"\n\n        strings = [str(x) for x in tup]\n\n        stringified = \"\".join(strings)\n\n        return stringified\n\n    def _model_var_create(self):\n\n        self._df[\"mip_vars\"] = self._df.apply(\n            lambda x: self.model.add_var(\n                var_type=mip.BINARY, name=f\"x_{self._stringify_tuple(x.name)}\"\n            ),\n            axis=1,\n        )\n\n    def _base_constraint(self, space:str, time:str):\n\"\"\"Constraint making the 'ones' constraint, making an intervention a binary intervention.\n\n        Args:\n            space (str): name of dataframe's column with information on regions/locations\n            time (str): name of dataframe's column with information on time/years\n        \"\"\"\n        grouped_df = self._df[\"mip_vars\"].groupby([space, time]).agg(mip.xsum)\n\n        base_constrs = grouped_df.values\n\n        # Get constraint name\n        names = list(\n            map(\n                self._stringify_tuple,\n                grouped_df.index.to_list()\n            )\n        )\n\n        for constr, name in zip(base_constrs, names):\n\n            self.model += constr &lt;= 1, \"ones_\" + name\n\n    def _intervention_subset(self, intervention:str, strict:bool, subset_names:list =[])-&gt; dict:\n\"\"\"This function creates a dictionary for the subset of specified interventions\n\n        Args:\n            intervention (str): name of dataframe's column with set of interventions \n            strict (bool): whether to look for specific intervention names (using DataFrame.isin) or whether to look for a regex (using DataFrame.str.contains)\n            subset_names (list, optional): Which intervention names to look for. Defaults to [].\n\n        Returns:\n            dict: dictionary with subset of interventions\n        \"\"\"\n\n        subset_dict = {}\n\n        for i in subset_names:\n\n            if strict:\n                subset_dict[i[0]] = self._df.loc[\n                    lambda df: df.index.get_level_values(level=intervention).isin([i])\n                ]\n\n                if subset_dict[i[0]].empty:\n                    raise Exception(f\"'{i[0]}' not found in dataset.\")\n\n            else:\n                subset_dict[i] = self._df.loc[\n                    lambda df: df.index.get_level_values(\n                        level=intervention\n                    ).str.contains(i, case=False)\n                ]\n\n                if subset_dict[i].empty:\n                    raise Exception(f\"'{i}' not found in dataset.\")\n\n        return subset_dict\n\n    def _all_constraint(\n        self,\n        strict:bool,\n        intervention:str=None,\n        space:str=None,\n        time:str=None,\n        subset_names:list=None,\n        over:str=None,\n        subset_list:list=None,\n    ):\n\"\"\"A constraint across space or time, where an intervention is tied to other interventions across space time (for a given subset). For instance, if you wanted to\n        create a national intervention, for some intervention X, with 2 regions, this constraint would do the following:\n\n        $X_{region1,t} == X_{region2,t}$ -&gt; _all_constraint(over='space', subset_names=None)\n\n        If you wanted to make sure that interventions were tied across time so that period 2 could only be used if period 1 was used:\n\n        $X_{region1, 1} == X_{region1, 2}$\n\n        Args:\n            strict (bool): whether to look for specific intervention names (using DataFrame.isin) or whether to look for a regex (using DataFrame.str.contains)\n            intervention (str, optional): name of dataframe's column with set of interventions. Defaults to None.\n            space (str, optional): name of dataframe's column with information on regions/locations. Defaults to None.\n            time (str, optional): name of dataframe's column with information on time/year. Defaults to None.\n            subset_names (list, optional): Which intervention names to look for. Defaults to None.\n            over (str, optional): name of dataframe's column  with attribute used to group data by (e.g., time, region). Defaults to None.\n            subset_list (list, optional): A list of interventions that are being constrained. Defaults to None.\n        \"\"\"\n\n        subset_dict = self._intervention_subset(\n            intervention=intervention, strict=strict, subset_names=subset_names\n        )\n        for sub in subset_dict.keys():\n\n            mip_vars_grouped_sum = (\n                subset_dict[sub].groupby([space, time])[\"mip_vars\"].agg(mip.xsum)\n            )\n\n            if over == time:\n                slicer = space\n            elif over == space:\n                slicer = time\n\n            unstacked = mip_vars_grouped_sum.unstack(level=slicer)\n\n            if subset_list is None:\n                subset_list = unstacked.index\n\n            # get combinations of different choices\n            constraint_combinations = permutations(unstacked.index.tolist(), 2)\n\n            constraint_list = [\n                (i, j) for (i, j) in constraint_combinations if i in subset_list\n            ]\n\n            for col in unstacked.columns:\n                for (comb1, comb2) in constraint_list:\n                    self.add_constraint(\n                        unstacked[col].loc[comb1], unstacked[col].loc[comb2], \n                        \"eq\",\n                        name = str(sub) + \"_\" + str(col) + \"_\" + str(comb1) + \"_\" + str(comb2)\n                    )\n\n    def _all_space_constraint(\n        self,\n        strict:bool,\n        intervention:str=None,\n        space:str=None,\n        time:str=None,\n        subset_names:list=None,\n        over:str=None,\n        subset_list:list=None,\n    )-&gt;None:\n\"\"\"This function invokes the function `_all_constraint' to create national interventions\n\n        Args:\n            strict (bool): whether to look for specific intervention names (using DataFrame.isin) or whether to look for a regex (using DataFrame.str.contains)\n            intervention (str, optional): name of dataframe's column with set of interventions. Defaults to None.\n            space (str, optional): name of dataframe's column with informaiton on regions/locations. Defaults to None.\n            time (str, optional): name of dataframe's column with information on time/year. Defaults to None.\n            subset_names (list, optional): Which intervention names to look for. Defaults to None.\n            over (str, optional): name of dataframe's column  with attribute used to group data by (e.g., time, region). Defaults to None.\n            subset_list (list, optional): A list of interventions that are being constrained. Defaults to None.\n        \"\"\"\n\n        return self._all_constraint(\n            strict,\n            intervention=intervention,\n            space=space,\n            time=time,\n            subset_names=subset_names,\n            over=over,\n            subset_list=subset_list,\n        )\n\n    def _all_time_constraint(\n        self,\n        strict:bool,\n        intervention:str=None,\n        space:str=None,\n        time:str=None,\n        subset_names:list=None,\n        over:str=None,\n        subset_list:list=None,\n    )-&gt;None:\n\"\"\"This function invokes the function `_all_constraint'\n\n        Args:\n            strict (bool): whether to look for specific intervention names (using DataFrame.isin) or whether to look for a regex (using DataFrame.str.contains)\n            intervention (str, optional): name of dataframe's column with set of interventions. Defaults to None.\n            space (str, optional): name of dataframe's column with information on regions/locations. Defaults to None.\n            time (str, optional): name of dataframe's column with information on time/year. Defaults to None.\n            subset_names (list, optional): Which intervention names to look for. Defaults to None.\n            over (str, optional): name of dataframe's column  with attribute used to group data by (e.g., time, region). Defaults to None.\n            subset_list (list, optional): A list of interventions that are being constrained. Defaults to None.\n        \"\"\"\n\n        return self._all_constraint(\n            strict,\n            intervention=intervention,\n            space=space,\n            time=time,\n            subset_names=subset_names,\n            over=over,\n            subset_list=subset_list,\n        )\n\n\n    def get_equation(self, name:str=None, show:bool=True)-&gt;str or mip.LinExpr or mip.Constr :\n\"\"\"This function returns a constraint by its name. If no name is specified, returns all constraints\n\n        Args:\n            name (str, optional): a string corresponding to the name of the constraint. Defaults to None.\n            show (bool, optional): whether to return the contraint in string type or not. Defaults to True.\n\n        Returns:\n            str or mip.LinExpr or mip.Constr: A `mip` constraint object\n        \"\"\"\n\n        if name is None:\n            return self.model.constrs\n        elif name == 'objective':\n            if show:\n                return str(self.model.objective)\n            else:\n                return self.model.objective\n        else:\n            if show:\n                return str(self.model.constr_by_name(name))\n            else:\n                return self.model.constr_by_name(name)\n\n    def add_objective(self, eq:mip.LinExpr):\n\"\"\"Sets the objective function of the problem as a linear expression\n\n        Args:\n            eq (mip.LinExpr): equation defining the objective function\n        \"\"\"\n\n        self.model.objective = eq\n\n    def add_constraint(self, eq:mip.LinExpr, constraint:mip.LinExpr, way:str=\"ge\", name:str=\"\"):\n\"\"\"This function merges the objective function of the model with its constraint\n\n        Args:\n            eq (mip.LinExpr): equation defining the objective function\n            constraint (mip.LinExpr):equation defining the constraint function\n            way (str, optional): whether greater or equal (ge), less or equal(le), or equal(eq). Defaults to \"ge\".\n            name (str, optional): optional name for the constraint. Defaults to \"\".\n        \"\"\"\n\n        if isinstance(constraint, pd.Series):\n            # Merge equation with constraint\n            df = eq.merge(constraint, left_index = True, right_index= True)\n\n            for i, ee, c in df.itertuples():\n                if way == \"ge\":\n                    self.model += ee &gt;= c, name\n                elif way == \"le\":\n                    self.model += ee &lt;= c, name\n                elif way == \"eq\":\n                    self.model += ee == c, name\n\n\n        else:\n            if way == \"ge\":\n                self.model += eq &gt;= constraint, name\n            elif way == \"le\":\n                self.model += eq &lt;= constraint, name\n            elif way == \"eq\":\n                self.model += eq == constraint, name\n\n    def base_model_create(\n        self,\n        intervention:str,\n        space:str,\n        time:str,\n        all_time:list=None,\n        all_space:list=None,\n        time_subset:list=None,\n        space_subset:list=None,\n        strict:bool=False,\n    ):\n\"\"\"A function   \n\n        Args:\n            intervention (str): name of dataframe's column with set of interventions\n            space (str): name of dataframe's column with information on regions/locations\n            time (str): name of dataframe's column with information on time/years\n            all_time (list, optional): list of intervention vehicles that are active during all periods (e.g., cube, oil). Defaults to None.\n            all_space (list, optional): list of intervention vehicles that are targeted at a country-wide level (e.g., cube, oil). Defaults to None.\n            time_subset (list, optional): list with subset of periods. Defaults to None.\n            space_subset (list, optional):list with subset of regions/locations. Defaults to None.\n            strict (bool, optional): whether to look for specific intervention names (using DataFrame.isin) or whether to look for a regex (using DataFrame.str.contains). Defaults to False.\n\n        \"\"\"\n\n        ## Now we create the choice variable, x, which is binary and is the size of the dataset.\n        ## In this case, it should just be a column vector with the rows equal to the data:\n\n        self._model_var_create()\n\n        ## First add base constraint, which only allows one intervention per time and space\n        self._base_constraint(space, time)\n\n        ## Add all_space or all_time constraints if necessary\n        if all_time is not None:\n\n            if intervention is None or space is None:\n                raise Exception(\"One of the subset columns were not found\")\n\n            self._all_time_constraint(\n                strict,\n                intervention=intervention,\n                space=space,\n                time=time,\n                subset_names=all_time,\n                over=time,\n                subset_list=time_subset,\n            )\n\n        if all_space is not None:\n\n            if intervention is None or time is None:\n                raise Exception(\"One of the subset columns were not found\")\n\n            self._all_space_constraint(\n                strict,\n                intervention=intervention,\n                space=space,\n                time=time,\n                subset_names=all_space,\n                over=space,\n                subset_list=space_subset,\n            )\n\n    def optimize(self, **kwargs):\n\"\"\"This function conducts the optimization procedure \n\n        Args:\n            **kwargs: Other parameters for optimization procedure using `mip.optimize' (max_seconds, max_nodes, max_solutions)\n        \"\"\"\n\n        self.status = None\n\n        if self.model.num_cols == 0:\n            raise NoVars(\"No Variables added to the model\")\n        if self.model.num_rows == 0:\n            raise NoConstraints(\"No constraints added to the model.\")\n        try:\n            self.model.objective\n        except Exception:\n            raise NoObjective(\"No Objective added to the model\")\n\n        # Now, allow for arguments to the optimize function to be given:\n\n        max_seconds = kwargs.pop(\"max_seconds\", mip.INF)\n        max_nodes = kwargs.pop(\"max_nodes\", mip.INF)\n        max_solutions = kwargs.pop(\"max_solutions\", mip.INF)\n\n        if self.show_output:\n            self.status = self.model.optimize(max_seconds, max_nodes, max_solutions)\n        else:\n            with suppress_stdout_stderr():\n                self.status = self.model.optimize(max_seconds, max_nodes, max_solutions)\n        if self.show_output:\n            if self.status == mip.OptimizationStatus.OPTIMAL:\n                print(\"[Note]: Optimal Solution Found\")\n            elif self.status == mip.OptimizationStatus.FEASIBLE:\n                print(\"[Note]: Feasible Solution Found. This may not be optimal.\")\n            elif self.status == mip.OptimizationStatus.NO_SOLUTION_FOUND:\n                print(\"[Warning]: No Solution Found\")\n            elif self.status == mip.OptimizationStatus.INFEASIBLE:\n                print(\"[Warning]: Infeasible Solution Found\")\n\n    def process_results(self, benefit_col:str, cost_col:str, intervention_col:str, space_col:str, sol_num:int = None)-&gt;pd.DataFrame:\n\"\"\"This function creates a dataframe with information on benefits and costs for the optimal interventions\n\n        Args:\n            benefit_col (str): name of dataframe's column with benefits\n            cost_col (str): name of dataframe's column with costs\n            intervention_col (str): name of dataframe's column with set of interventions\n            space_col (str): name of dataframe's column with information on regions/locations\n            sol_num (int, optional): index of solution. Defaults to None.\n\n        Returns:\n            pd.DataFrame: dataframe with optimal interventions\n        \"\"\"\n\n\n        if isinstance(sol_num, int):\n            opt_df = self._df.copy(deep=True).assign(opt_vals=lambda df: df[\"mip_vars\"].apply(lambda y: y.xi(sol_num)))\n        else:\n            opt_df = self._df.copy(deep=True).assign(\n                opt_vals=lambda df: df[\"mip_vars\"].apply(lambda y: y.x))\n\n        opt_df = (opt_df.assign(\n            opt_benefit=lambda df: df[benefit_col] * df[\"opt_vals\"],\n            opt_costs=lambda df: df[cost_col] * df[\"opt_vals\"],\n            opt_costs_discounted=lambda df: df[\"discounted_costs\"] * df[\"opt_vals\"],\n            opt_benefit_discounted=lambda df: df[\"discounted_benefits\"]* df[\"opt_vals\"])\n                  .infer_objects()\n                  .assign(\n            cumulative_discounted_benefits = lambda df: (df\n                                                         .groupby([space_col])['opt_benefit_discounted']\n                                                         .transform('cumsum')),\n            cumulative_discounted_costs = lambda df: (df\n                                                         .groupby([space_col])['opt_costs_discounted']\n                                                         .transform('cumsum')),\n            cumulative_benefits = lambda df: (df\n                                                         .groupby([space_col])['opt_benefit']\n                                                         .transform('cumsum')),\n            cumulative_costs = lambda df: (df\n                                                         .groupby([space_col])['opt_costs']\n                                                         .transform('cumsum'))\n        )[\n            [\n                \"opt_vals\",\n                \"opt_benefit\",\n                \"opt_costs\",\n                \"opt_costs_discounted\",\n                \"opt_benefit_discounted\",\n                \"cumulative_discounted_benefits\",\n                \"cumulative_discounted_costs\",\n                \"cumulative_benefits\",\n                \"cumulative_costs\"\n                ]\n        ])\n\n\n        return opt_df\n\n    def write(self, filename:str=\"model.lp\"):\n\"\"\"Thi function saves model to file\n\n        Args:\n            filename (str, optional): name of file. Defaults to \"model.lp\".\n        \"\"\"\n        self.model.write(filename)\n\n    def get_model_results(self)-&gt;list:\n\"\"\"This function returns a list with additional results of the optimization procedure\n\n        Returns:\n            list: model's results\n        \"\"\"\n\n        return (\n            self.model.objective_value,\n            self.model.objective_values,\n            self.model.objective_bound,\n            self.model.num_solutions,\n            self.model.num_cols,\n            self.model.num_rows,\n            self.model.num_int,\n            self.model.num_nz,\n            self.status,\n        )\n</code></pre>"},{"location":"base/#minimod_opt.base.model.Model.__init__","title":"<code>__init__(data, sense, solver_name, show_output)</code>","text":"<p>A class that instantiates a <code>mip</code> model.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>The input dataframe that includes benefit/cost data</p> required <code>sense</code> <code>str</code> <p>Whether the model should minimize (MINIMIZE) or maximize (MAXIMIZE)</p> required <code>solver_name</code> <code>str</code> <p>The solver type (CBC or some other mip solver)</p> required <code>show_output</code> <code>bool</code> <p>Whether to show output of model construction</p> required Source code in <code>minimod_opt/base/model.py</code> <pre><code>def __init__(self, data:pd.DataFrame, sense:str, solver_name:str, show_output:bool):\n\"\"\"A class that instantiates a `mip` model.\n\n    Args:\n        data (pd.DataFrame): The input dataframe that includes benefit/cost data\n        sense (str): Whether the model should minimize (MINIMIZE) or maximize (MAXIMIZE)\n        solver_name (str): The solver type (CBC or some other mip solver)\n        show_output (bool):  Whether to show output of model construction\n    \"\"\"\n\n\n    ## Tell the fitter whether to maximize or minimize\n    self.model = mip.Model(sense=sense, solver_name=solver_name)\n\n    self._df = data\n\n    self.show_output = show_output\n\n    if self.show_output:\n        self.model.verbose = 1\n    else:\n        self.model.verbose = 0\n</code></pre>"},{"location":"base/#minimod_opt.base.model.Model.add_constraint","title":"<code>add_constraint(eq, constraint, way='ge', name='')</code>","text":"<p>This function merges the objective function of the model with its constraint</p> <p>Parameters:</p> Name Type Description Default <code>eq</code> <code>mip.LinExpr</code> <p>equation defining the objective function</p> required <code>constraint</code> <code>mip.LinExpr</code> <p>equation defining the constraint function</p> required <code>way</code> <code>str</code> <p>whether greater or equal (ge), less or equal(le), or equal(eq). Defaults to \"ge\".</p> <code>'ge'</code> <code>name</code> <code>str</code> <p>optional name for the constraint. Defaults to \"\".</p> <code>''</code> Source code in <code>minimod_opt/base/model.py</code> <pre><code>def add_constraint(self, eq:mip.LinExpr, constraint:mip.LinExpr, way:str=\"ge\", name:str=\"\"):\n\"\"\"This function merges the objective function of the model with its constraint\n\n    Args:\n        eq (mip.LinExpr): equation defining the objective function\n        constraint (mip.LinExpr):equation defining the constraint function\n        way (str, optional): whether greater or equal (ge), less or equal(le), or equal(eq). Defaults to \"ge\".\n        name (str, optional): optional name for the constraint. Defaults to \"\".\n    \"\"\"\n\n    if isinstance(constraint, pd.Series):\n        # Merge equation with constraint\n        df = eq.merge(constraint, left_index = True, right_index= True)\n\n        for i, ee, c in df.itertuples():\n            if way == \"ge\":\n                self.model += ee &gt;= c, name\n            elif way == \"le\":\n                self.model += ee &lt;= c, name\n            elif way == \"eq\":\n                self.model += ee == c, name\n\n\n    else:\n        if way == \"ge\":\n            self.model += eq &gt;= constraint, name\n        elif way == \"le\":\n            self.model += eq &lt;= constraint, name\n        elif way == \"eq\":\n            self.model += eq == constraint, name\n</code></pre>"},{"location":"base/#minimod_opt.base.model.Model.add_objective","title":"<code>add_objective(eq)</code>","text":"<p>Sets the objective function of the problem as a linear expression</p> <p>Parameters:</p> Name Type Description Default <code>eq</code> <code>mip.LinExpr</code> <p>equation defining the objective function</p> required Source code in <code>minimod_opt/base/model.py</code> <pre><code>def add_objective(self, eq:mip.LinExpr):\n\"\"\"Sets the objective function of the problem as a linear expression\n\n    Args:\n        eq (mip.LinExpr): equation defining the objective function\n    \"\"\"\n\n    self.model.objective = eq\n</code></pre>"},{"location":"base/#minimod_opt.base.model.Model.base_model_create","title":"<code>base_model_create(intervention, space, time, all_time=None, all_space=None, time_subset=None, space_subset=None, strict=False)</code>","text":"<p>A function   </p> <p>Parameters:</p> Name Type Description Default <code>intervention</code> <code>str</code> <p>name of dataframe's column with set of interventions</p> required <code>space</code> <code>str</code> <p>name of dataframe's column with information on regions/locations</p> required <code>time</code> <code>str</code> <p>name of dataframe's column with information on time/years</p> required <code>all_time</code> <code>list</code> <p>list of intervention vehicles that are active during all periods (e.g., cube, oil). Defaults to None.</p> <code>None</code> <code>all_space</code> <code>list</code> <p>list of intervention vehicles that are targeted at a country-wide level (e.g., cube, oil). Defaults to None.</p> <code>None</code> <code>time_subset</code> <code>list</code> <p>list with subset of periods. Defaults to None.</p> <code>None</code> <code>space_subset</code> <code>list</code> <p>list with subset of regions/locations. Defaults to None.</p> <code>None</code> <code>strict</code> <code>bool</code> <p>whether to look for specific intervention names (using DataFrame.isin) or whether to look for a regex (using DataFrame.str.contains). Defaults to False.</p> <code>False</code> Source code in <code>minimod_opt/base/model.py</code> <pre><code>def base_model_create(\n    self,\n    intervention:str,\n    space:str,\n    time:str,\n    all_time:list=None,\n    all_space:list=None,\n    time_subset:list=None,\n    space_subset:list=None,\n    strict:bool=False,\n):\n\"\"\"A function   \n\n    Args:\n        intervention (str): name of dataframe's column with set of interventions\n        space (str): name of dataframe's column with information on regions/locations\n        time (str): name of dataframe's column with information on time/years\n        all_time (list, optional): list of intervention vehicles that are active during all periods (e.g., cube, oil). Defaults to None.\n        all_space (list, optional): list of intervention vehicles that are targeted at a country-wide level (e.g., cube, oil). Defaults to None.\n        time_subset (list, optional): list with subset of periods. Defaults to None.\n        space_subset (list, optional):list with subset of regions/locations. Defaults to None.\n        strict (bool, optional): whether to look for specific intervention names (using DataFrame.isin) or whether to look for a regex (using DataFrame.str.contains). Defaults to False.\n\n    \"\"\"\n\n    ## Now we create the choice variable, x, which is binary and is the size of the dataset.\n    ## In this case, it should just be a column vector with the rows equal to the data:\n\n    self._model_var_create()\n\n    ## First add base constraint, which only allows one intervention per time and space\n    self._base_constraint(space, time)\n\n    ## Add all_space or all_time constraints if necessary\n    if all_time is not None:\n\n        if intervention is None or space is None:\n            raise Exception(\"One of the subset columns were not found\")\n\n        self._all_time_constraint(\n            strict,\n            intervention=intervention,\n            space=space,\n            time=time,\n            subset_names=all_time,\n            over=time,\n            subset_list=time_subset,\n        )\n\n    if all_space is not None:\n\n        if intervention is None or time is None:\n            raise Exception(\"One of the subset columns were not found\")\n\n        self._all_space_constraint(\n            strict,\n            intervention=intervention,\n            space=space,\n            time=time,\n            subset_names=all_space,\n            over=space,\n            subset_list=space_subset,\n        )\n</code></pre>"},{"location":"base/#minimod_opt.base.model.Model.get_equation","title":"<code>get_equation(name=None, show=True)</code>","text":"<p>This function returns a constraint by its name. If no name is specified, returns all constraints</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>a string corresponding to the name of the constraint. Defaults to None.</p> <code>None</code> <code>show</code> <code>bool</code> <p>whether to return the contraint in string type or not. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>str or mip.LinExpr or mip.Constr: A <code>mip</code> constraint object</p> Source code in <code>minimod_opt/base/model.py</code> <pre><code>def get_equation(self, name:str=None, show:bool=True)-&gt;str or mip.LinExpr or mip.Constr :\n\"\"\"This function returns a constraint by its name. If no name is specified, returns all constraints\n\n    Args:\n        name (str, optional): a string corresponding to the name of the constraint. Defaults to None.\n        show (bool, optional): whether to return the contraint in string type or not. Defaults to True.\n\n    Returns:\n        str or mip.LinExpr or mip.Constr: A `mip` constraint object\n    \"\"\"\n\n    if name is None:\n        return self.model.constrs\n    elif name == 'objective':\n        if show:\n            return str(self.model.objective)\n        else:\n            return self.model.objective\n    else:\n        if show:\n            return str(self.model.constr_by_name(name))\n        else:\n            return self.model.constr_by_name(name)\n</code></pre>"},{"location":"base/#minimod_opt.base.model.Model.get_model_results","title":"<code>get_model_results()</code>","text":"<p>This function returns a list with additional results of the optimization procedure</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>model's results</p> Source code in <code>minimod_opt/base/model.py</code> <pre><code>def get_model_results(self)-&gt;list:\n\"\"\"This function returns a list with additional results of the optimization procedure\n\n    Returns:\n        list: model's results\n    \"\"\"\n\n    return (\n        self.model.objective_value,\n        self.model.objective_values,\n        self.model.objective_bound,\n        self.model.num_solutions,\n        self.model.num_cols,\n        self.model.num_rows,\n        self.model.num_int,\n        self.model.num_nz,\n        self.status,\n    )\n</code></pre>"},{"location":"base/#minimod_opt.base.model.Model.optimize","title":"<code>optimize(**kwargs)</code>","text":"<p>This function conducts the optimization procedure </p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Other parameters for optimization procedure using `mip.optimize' (max_seconds, max_nodes, max_solutions)</p> <code>{}</code> Source code in <code>minimod_opt/base/model.py</code> <pre><code>def optimize(self, **kwargs):\n\"\"\"This function conducts the optimization procedure \n\n    Args:\n        **kwargs: Other parameters for optimization procedure using `mip.optimize' (max_seconds, max_nodes, max_solutions)\n    \"\"\"\n\n    self.status = None\n\n    if self.model.num_cols == 0:\n        raise NoVars(\"No Variables added to the model\")\n    if self.model.num_rows == 0:\n        raise NoConstraints(\"No constraints added to the model.\")\n    try:\n        self.model.objective\n    except Exception:\n        raise NoObjective(\"No Objective added to the model\")\n\n    # Now, allow for arguments to the optimize function to be given:\n\n    max_seconds = kwargs.pop(\"max_seconds\", mip.INF)\n    max_nodes = kwargs.pop(\"max_nodes\", mip.INF)\n    max_solutions = kwargs.pop(\"max_solutions\", mip.INF)\n\n    if self.show_output:\n        self.status = self.model.optimize(max_seconds, max_nodes, max_solutions)\n    else:\n        with suppress_stdout_stderr():\n            self.status = self.model.optimize(max_seconds, max_nodes, max_solutions)\n    if self.show_output:\n        if self.status == mip.OptimizationStatus.OPTIMAL:\n            print(\"[Note]: Optimal Solution Found\")\n        elif self.status == mip.OptimizationStatus.FEASIBLE:\n            print(\"[Note]: Feasible Solution Found. This may not be optimal.\")\n        elif self.status == mip.OptimizationStatus.NO_SOLUTION_FOUND:\n            print(\"[Warning]: No Solution Found\")\n        elif self.status == mip.OptimizationStatus.INFEASIBLE:\n            print(\"[Warning]: Infeasible Solution Found\")\n</code></pre>"},{"location":"base/#minimod_opt.base.model.Model.process_results","title":"<code>process_results(benefit_col, cost_col, intervention_col, space_col, sol_num=None)</code>","text":"<p>This function creates a dataframe with information on benefits and costs for the optimal interventions</p> <p>Parameters:</p> Name Type Description Default <code>benefit_col</code> <code>str</code> <p>name of dataframe's column with benefits</p> required <code>cost_col</code> <code>str</code> <p>name of dataframe's column with costs</p> required <code>intervention_col</code> <code>str</code> <p>name of dataframe's column with set of interventions</p> required <code>space_col</code> <code>str</code> <p>name of dataframe's column with information on regions/locations</p> required <code>sol_num</code> <code>int</code> <p>index of solution. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: dataframe with optimal interventions</p> Source code in <code>minimod_opt/base/model.py</code> <pre><code>def process_results(self, benefit_col:str, cost_col:str, intervention_col:str, space_col:str, sol_num:int = None)-&gt;pd.DataFrame:\n\"\"\"This function creates a dataframe with information on benefits and costs for the optimal interventions\n\n    Args:\n        benefit_col (str): name of dataframe's column with benefits\n        cost_col (str): name of dataframe's column with costs\n        intervention_col (str): name of dataframe's column with set of interventions\n        space_col (str): name of dataframe's column with information on regions/locations\n        sol_num (int, optional): index of solution. Defaults to None.\n\n    Returns:\n        pd.DataFrame: dataframe with optimal interventions\n    \"\"\"\n\n\n    if isinstance(sol_num, int):\n        opt_df = self._df.copy(deep=True).assign(opt_vals=lambda df: df[\"mip_vars\"].apply(lambda y: y.xi(sol_num)))\n    else:\n        opt_df = self._df.copy(deep=True).assign(\n            opt_vals=lambda df: df[\"mip_vars\"].apply(lambda y: y.x))\n\n    opt_df = (opt_df.assign(\n        opt_benefit=lambda df: df[benefit_col] * df[\"opt_vals\"],\n        opt_costs=lambda df: df[cost_col] * df[\"opt_vals\"],\n        opt_costs_discounted=lambda df: df[\"discounted_costs\"] * df[\"opt_vals\"],\n        opt_benefit_discounted=lambda df: df[\"discounted_benefits\"]* df[\"opt_vals\"])\n              .infer_objects()\n              .assign(\n        cumulative_discounted_benefits = lambda df: (df\n                                                     .groupby([space_col])['opt_benefit_discounted']\n                                                     .transform('cumsum')),\n        cumulative_discounted_costs = lambda df: (df\n                                                     .groupby([space_col])['opt_costs_discounted']\n                                                     .transform('cumsum')),\n        cumulative_benefits = lambda df: (df\n                                                     .groupby([space_col])['opt_benefit']\n                                                     .transform('cumsum')),\n        cumulative_costs = lambda df: (df\n                                                     .groupby([space_col])['opt_costs']\n                                                     .transform('cumsum'))\n    )[\n        [\n            \"opt_vals\",\n            \"opt_benefit\",\n            \"opt_costs\",\n            \"opt_costs_discounted\",\n            \"opt_benefit_discounted\",\n            \"cumulative_discounted_benefits\",\n            \"cumulative_discounted_costs\",\n            \"cumulative_benefits\",\n            \"cumulative_costs\"\n            ]\n    ])\n\n\n    return opt_df\n</code></pre>"},{"location":"base/#minimod_opt.base.model.Model.write","title":"<code>write(filename='model.lp')</code>","text":"<p>Thi function saves model to file</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>name of file. Defaults to \"model.lp\".</p> <code>'model.lp'</code> Source code in <code>minimod_opt/base/model.py</code> <pre><code>def write(self, filename:str=\"model.lp\"):\n\"\"\"Thi function saves model to file\n\n    Args:\n        filename (str, optional): name of file. Defaults to \"model.lp\".\n    \"\"\"\n    self.model.write(filename)\n</code></pre>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver","title":"<code>BaseSolver</code>","text":"Source code in <code>minimod_opt/base/basesolver.py</code> <pre><code>class BaseSolver:\n\n\n    def __init__(\n        self,\n        data: pd.DataFrame,\n        benefit_col: str = 'benefits',\n        cost_col: str = 'costs',\n        intervention_col: str = 'intervention',\n        space_col: str = 'space',\n        time_col: str = 'time',\n        interest_rate_cost: float = 0.0,  # Discount factor for costs\n        interest_rate_benefit: float = 0.03,  # Discount factor for benefits \n        va_weight: float = 1.0,  # VA Weight\n        sense: str = None,  # MIP optimization type (maximization or minimization)\n        solver_name: str = mip.CBC,  # Solver for MIP to use\n        show_output: bool = True,\n        benefit_title: str = \"Benefits\",\n    ):       \n\n\"\"\"The base solver for the Optimization. This sets up the basic setup of the model, which includes:\n        - data handling\n        - BAU constraint creation\n        - base model constraint creation\n\n        Args:\n                data (pd.DataFrame): dataframe with benefits and cost data.\n                benefit_col (str, optional): name of dataframe's column with benefit data. Defaults to 'benefits'.\n                cost_col (str, optional): name of dataframe's column with cost data. Defaults to 'costs'.\n                intervention_col (str, optional): name of dataframe's column with intervention data. Defaults to 'intervention'.\n                space_col (str, optional): name of dataframe's column with space/region data . Defaults to 'space'.\n                time_col (str, optional): name of dataframe's column with time period data . Defaults to 'time'.\n                interest_rate_cost (float, optional): interest rate of costs. Defaults to 0.0.\n                benefit_title (str, optional): title for benefits to use in plots and reports. Defaults to \"Benefits\".\n\n        ``BaseSolver`` is inherited by ``CostSolver`` and ``BenefitSolver`` to then run optimizations.\n        \"\"\"        \n\n        self.interest_rate_cost = interest_rate_cost\n        self.interest_rate_benefit = interest_rate_benefit\n        self.va_weight = va_weight\n        self.discount_costs = 1 / (1 + self.interest_rate_cost)\n        self.discount_benefits = 1 / (1 + self.interest_rate_benefit)\n        self.benefit_title = benefit_title\n\n        if sense is not None:\n            self.sense = sense\n        else:\n            raise Exception(\"No Optimization Method was specified\")\n\n        self.solver_name = solver_name\n        self.show_output = show_output\n\n        # Process Data\n\n        if self.show_output:\n            print(\"[Note]: Processing Data...\")\n\n        self._df = self._process_data(\n            data=data,\n            intervention=intervention_col,\n            space=space_col,\n            time=time_col,\n            benefits=benefit_col,\n            costs=cost_col,\n        )\n\n\n        self.benefit_col = benefit_col\n        self.cost_col = cost_col\n        self.intervention_col = intervention_col\n        self.space_col = space_col\n        self.time_col = time_col\n\n        if self.show_output:\n            print(\"[Note]: Creating Base Model with constraints\")\n\n\n        self.minimum_benefit = None\n        self.total_funds = None\n\n        self.message = f\"\"\"\n                MiniMod Nutrition Intervention Tool\n                Optimization Method: {str(self.sense)}\n                Solver: {str(self.solver_name)},\n                Show Output: {self.show_output}\n\n                \"\"\"\n\n        if self.show_output:\n            print(self.message)\n\n\n\n    def _discounted_sum_all(self, col_name:str) -&gt; mip.LinExpr:\n\n\"\"\"Multiply each ``mip_var`` in the data by benefits or costs (``data``) and then create a ``mip`` expression from it.\n\n        Args:\n            col_name (str): name of dataframe's column with benefits or costs data\n\n        Returns:\n            mip.LinExpr: ``mip`` Expression\n        \"\"\"    \n\n        eq = (self._df['mip_vars'] * self._df[col_name]).agg(mip.xsum)\n\n        return eq\n\n    def _discounted_sum_over(self, col_name: str, over: str) -&gt; pd.DataFrame :\n\"\"\"Abstract function used for constructing the objective function and main constraint of the model\n\n        Args:\n            col_name (str): name of dataframe's column with benefits or costs data\n            over (str): name of dataframe's column with attribute used to group data by (e.g. time)\n\n        Returns:\n            (pd.Dataframe): pd.Dataframe with mip variables as observations\n        \"\"\"\n\n        # Merge data with self._df   \n        eq = (self._df['mip_vars'] * self._df[col_name]).groupby(over).agg(mip.xsum)\n\n        return eq.to_frame().rename({0 : col_name + '_vars'}, axis=1)\n\n\n    def _is_dataframe(self, data: Any):\n\"\"\"Checks if input dataset is a ``pandas.DataFrame``\n\n        Args:\n            data (Any): input data\n\n        Raises:\n            NotPandasDataframe: Exception if not a ``pandas.DataFrame``\n        \"\"\"    \n\n        if not isinstance(data, pd.DataFrame):\n            raise NotPandasDataframe(\n                \"[Error]: Input data is not a dataframe. Please input a dataframe.\"\n            )\n\n\n    def _process_data(\n        self,\n        data: pd.DataFrame = None,\n        intervention: str =\"intervention\",\n        space: str = \"space\",\n        time: str = \"time\",\n        benefits: str = \"benefits\",\n        costs: str = \"costs\",\n    ) -&gt; pd.DataFrame :      \n\"\"\"Processes the input data by creating discounted benefits and costs.\n\n        Args:\n            data (pd.DataFrame, optional): raw data to be processed. Defaults to None.\n            intervention (str, optional): name of dataframe's column with intervention data. Defaults to \"intervention\".\n            space (str, optional): name of dataframe's column with space/region data. Defaults to \"space\".\n            time (str, optional): name of dataframe's column with time period data. Defaults to \"time\".\n            benefits (str, optional): name of dataframe's column with benefits data. Defaults to \"benefits\".\n            costs (str, optional): name of dataframe's column with cost data. Defaults to \"costs\".\n\n        Returns:\n            (pd.DataFrame): dataframe ready to be used in the problem\n\n\n        |k     | j   |t   | benefits   | costs |\n        |------|-----|----|------------|-------|\n        |maize |north|0   | 100        | 10    |\n        |maize |south|0   | 50         | 20    |\n        |maize |east |0   | 30         |30     |\n        |maize |west |0   | 20         |40     |\n\n        \"\"\"\n\n        ## First do some sanity checks\n        if data is None:\n            raise MissingData(\"No data specified.\")\n\n        # Check if dataframe\n        self._is_dataframe(data)\n\n        df_aux = (\n            data.reset_index()\n            .assign(\n                time_col=lambda df: df[time].astype(int),\n                time_rank=lambda df: (\n                    df[time].rank(numeric_only=True, method=\"dense\") - 1\n                ).astype(int),\n                time_discount_costs=lambda df: self.discount_costs ** df[\"time_rank\"],\n                time_discount_benefits=lambda df: self.discount_benefits\n                ** df[\"time_rank\"],\n                discounted_costs=lambda df: df[\"time_discount_costs\"] * df[costs],\n                discounted_benefits=lambda df: df[\"time_discount_benefits\"]*df[benefits]\n            )\n        )\n\n        df_aux[intervention] = df_aux[intervention].str.lstrip().str.rstrip()\n\n        df = (\n            df_aux\n            .set_index([intervention, space, time])\n            .sort_index(level=(intervention, space, time))\n        )\n\n        return df\n\n    def _constraint(self):\n\"\"\"This function defines the constraints for the mips model.\n        To be overridden by BenefitSolver and CostSolver classes.\n        \"\"\"\n        self.constraint_called = 0\n\n    def _objective(self):\n\"\"\"This function defines the objective function for a model.\n        To be overridden by BenefitSolver and CostSolver classes.\n        \"\"\"\n        pass\n\n\n    def _fit(self, **kwargs) -&gt; str:\n\"\"\"Fits data to model. The instantiation of the class creates the base model. Uses ``mip.optimize`` to find the optimal point.\n\n        Args:\n            *kwargs: Other parameters to send to mip.optimize\n\n        Returns:\n            str: return self\n        \"\"\"\n\n\n        if self.show_output:\n            print(\"[Note]: Optimizing...\")\n\n        self.model.optimize(**kwargs)  \n\n        (self.objective_value,\n         self.objective_values, \n         self.objective_bound, \n         self.num_solutions, \n         self.num_cols, \n         self.num_rows, \n         self.num_int, \n         self.num_nz, \n         self.status) = self.model.get_model_results()\n\n        return self\n\n    def write(self, filename:str=\"model.lp\"):\n\"\"\"Save model to file\n\n        Args:\n            filename (str, optional):name of the file. Defaults to \"model.lp\".\n        \"\"\"\n\n        self.model.write(filename)\n\n    def process_results(self, sol_num:int=None):\n\"\"\"Processes results of optimization to be used in visualization and reporting functions\n\n        Args:\n            sol_num (int, optional): index of solution. Defaults to None.\n        \"\"\"\n\n        self.opt_df = self.model.process_results(self.benefit_col, \n                                            self.cost_col, \n                                            self.intervention_col,\n                                            self.space_col,\n                                            sol_num=sol_num)\n\n\n    def report(self, sol_num:int=None, quiet:bool=False) -&gt; str:\n\"\"\"Prints out a report of optimal model parameters and useful statistics.\n\n        Args:\n            sol_num (int, optional): index of solution to be displayed. Defaults to None.\n            quiet (bool, optional): whether we want the report printed out or not. Defaults to False.\n        \"\"\"\n\n        self.opt_df = self.model.process_results(self.benefit_col, \n                                            self.cost_col, \n                                            self.intervention_col,\n                                            self.space_col,\n                                            sol_num=sol_num)\n\n        if quiet:\n            return\n        header = [\n            ('MiniMod Solver Results', \"\"),\n            (\"Method:\" , str(self.sense)),\n            (\"Solver:\", str(self.solver_name)),\n            (\"Optimization Status:\", str(self.status)),\n            (\"Number of Solutions Found:\", str(self.num_solutions))\n\n        ]\n\n        features = [\n            (\"No. of Variables:\", str(self.num_cols)),\n            (\"No. of Integer Variables:\", str(self.num_int)),\n            (\"No. of Constraints\", str(self.num_rows)),\n            (\"No. of Non-zeros in Constr.\", str(self.num_nz))\n        ]\n\n        s = OptimizationSummary(self)\n\n        s.print_generic(header, features)\n\n        print(\"Interventions Chosen:\")\n\n    @property\n    def optimal_interventions(self) -&gt; list:\n        opt_intervention = (\n            self.opt_df\n            .loc[lambda df: df['opt_vals']&gt;0]\n            .index\n            .get_level_values(level=self.intervention_col)\n            .unique()\n            .tolist()\n        )\n\"\"\"Outputs the unique set of optimal interventions as a list\n\n        Returns:\n            list: The list of optimal interventions\n        \"\"\"\n\n        return opt_intervention\n\n    @property\n    def _intervention_list_space_time(self) -&gt; pd.DataFrame:\n\"\"\"Returns a data frame with multindex (space_col, time_col) where each row is the optimal intervention.\n\n        Returns:\n            pd.DataFrame: A dataframe where each row is the optimal intervention for each time period and space\n        \"\"\"\n\n        df = (\n            self.opt_df['opt_vals']\n            .reset_index(level=self.intervention_col)\n            .assign(int_appeared= lambda df: df[self.intervention_col]*df['opt_vals'].astype(int))\n            .groupby([self.space_col, self.time_col])\n            ['int_appeared']\n            .agg(set)\n            .str.join('')\n        )\n\n        return df\n\n    @property\n    def bau_list(self) -&gt; pd.DataFrame:\n\"\"\"Returns a dataframe with the name of the bau intervention. Mostly done for compatibility with other methods.\n\n        Returns:\n            pd.DataFrame: dataframe with the name of the bau intervention\n        \"\"\"\n\n        df = (\n            self.bau_df\n            .reset_index(level=self.intervention_col)\n            .rename({self.intervention_col : 'int_appeared'}, axis=1)\n            ['int_appeared']\n        )\n\n        return df\n\n\n    def plot_time(self, \n                  fig: mpl.figure = None, \n                  ax: mpl.axis= None,\n                  save: str = None,\n                  cumulative: bool = False,\n                  cumulative_discount: bool = False) -&gt; mpl.figure:\n\"\"\"Plots optimal benefits and costs across time after model optimization\n\n        Args:\n            fig (matplotlib.figure, optional): matplotlib figure. Defaults to None.\n            ax (matplotlib.axis, optional): matplotlib axis to use. Defaults to None.\n            save (str, optional): path to save the figure. Defaults to None.\n            cumulative (bool, optional): whether to plot cumulative benefits or costs. Defaults to False.\n            cumulative_discount (bool, optional): whether to plot cumulative benefits or costs, discounted. Defaults to False.\n\n        Returns:\n            matplotlib.figure: figure with optimal benefits and cost across time\n        \"\"\"\n\n        p = Plotter(self)\n\n        if cumulative:\n            return p._plot_lines(to_plot = ['cumulative_benefits', 'cumulative_costs'],\n                    title= \"Optima over Time\",\n                    xlabel = 'Time',\n                    ylabel = self.benefit_title,\n                    twin =True,\n                    twin_ylabel= \"Currency\",\n                    save = save,\n                    legend = ['Cumm. ' + self.benefit_title,\n                            'Cumm. Costs'],\n                    figure=fig,\n                    axis=ax)\n        elif cumulative_discount:\n            return p._plot_lines(to_plot = ['cumulative_discounted_benefits', 'cumulative_discounted_costs'],\n                    title= \"Optima over Time\",\n                    xlabel = 'Time',\n                    ylabel = self.benefit_title,\n                    twin =True,\n                    twin_ylabel= \"Currency\",\n                    save = save,\n                    legend = ['Cumm. Dis. '+ self.benefit_title,\n                            'Cumm. Dis. Costs'],\n                    figure=fig,\n                    axis=ax)\n        else:\n            return p._plot_lines(to_plot = ['opt_benefit', 'opt_costs'],\n                                title= \"Optima over Time\",\n                                xlabel = 'Time',\n                                ylabel = self.benefit_title,\n                                twin =True,\n                                twin_ylabel= \"Currency\",\n                                save = save,\n                                legend = ['Optimal ' + self.benefit_title,\n                                        'Optimal Costs'],\n                                figure=fig,\n                                axis=ax)\n\n    def plot_bau_time(self,\n                      opt_variable: str = 'b',\n                      fig: mpl.figure = None,\n                      ax: mpl.axis = None,\n                      save: str = None):\n\"\"\"Plots benefits and costs of optimal and benchark interventions across time \n\n        Args:\n            opt_variable (str, optional): optimal variable to be plotted, where\n                b = optimal benefits\n                c = 'optimal costs\n                cdb = cumulative discounted benefits\n                cdc = cumulative discounted costs\n                cb = cumulative benefits\n                cc = cumulative costs\n            Defaults to 'b'.\n            fig (matplotlib.figure, optional): matplotlib figure. Defaults to None.\n            ax (matplotlib.axis, optional):matplotlib axis to use. Defaults to None.\n            save (str, optional): path to save the figure. Defaults to None.\n\n        Raises:\n            Exception: not one of the allowed variables for map plotting\n        \"\"\"\n\n        if ax is None:\n            fig, ax = plt.subplots()\n\n        p = Plotter(self)\n\n        if opt_variable == 'b':\n            opt = 'opt_benefit'\n            bau_col = self.benefit_col\n            title = \"Optimal \" + self.benefit_title + \" vs. BAU\"\n        elif opt_variable == 'c':\n            opt = 'opt_costs'\n            bau_col = self.cost_col\n            title = \"Optimal Costs vs. BAU\"\n        elif opt_variable == 'cdb':\n            opt = 'cumulative_discounted_benefits'\n            bau_col = 'discounted_benefits'\n            title = 'Cumulative Discounted ' + self.benefit_title\n        elif opt_variable == 'cdc':\n            opt = 'cumulative_discounted_costs'\n            bau_col = 'discounted_costs'\n            title = 'Cumulative Discounted Costs'\n        elif opt_variable == 'cb':\n            opt = 'cumulative_benefits'\n            bau_col = self.benefit_col\n            title = 'Cumulative ' + self.benefit_title      \n        elif opt_variable == 'cc':\n            opt = 'cumulative_costs'\n            bau_col = self.cost_col\n            title = 'Cumulative Costs'\n        else:\n            raise Exception(\"Not one of the allowed variables for map plotting. Try again.\")\n\n        if opt_variable in ['cdb', 'cdc', 'cb', 'cc']:\n\n            bench_df = (\n                self.bau_df\n                .groupby([self.time_col])\n                .sum().cumsum()\n                .assign(bench_col = lambda df: df[bau_col])\n                )\n\n        else:\n            bench_df = (\n                self.bau_df\n                .assign(bench_col = lambda df: df[bau_col])\n                .groupby([self.time_col])\n                .sum()\n                        )\n\n        p._plot_lines(to_plot = opt,\n                    title= title,\n                    xlabel = 'Time',\n                    figure=fig,\n                    axis=ax)\n\n        bench_df['bench_col'].plot(ax=ax)\n\n        ax.legend(['Optimal', 'BAU'])\n        ax.set_xlabel('Time')\n\n        if save is not None:\n            plt.savefig(save)\n\n\n\n    def plot_opt_val_hist(self, \n                          fig: mpl.figure = None, \n                          ax: mpl.axis = None, \n                          save: str = None) -&gt; mpl.figure:\n\"\"\"A histogram of the optimally chosen interventions\n\n        Args:\n            fig (matplotlib.figure, optional): figure instance to use. Defaults to None.\n            ax (matplotlib.axis, optional): axis instance to use. Defaults to None.\n            save (str, optional): path to save the figure. Defaults to None.\n\n        Returns:\n            matplotlib.figure: histogram figure\n        \"\"\"      \n\n        p = Plotter(self)\n\n        return p._plot_hist(to_plot = 'opt_vals',\n                            title = \"Optimal Choices\",\n                            xlabel = \"Time\",\n                            ylabel= \"\",\n                            figure = fig,\n                            axis = ax,\n                            save = save)  \n\n    def plot_chloropleth(self,\n                         intervention: str = None,\n                         time: Union[int,list] = None,\n                         optimum_interest: str = 'b',\n                         map_df: gpd.GeoDataFrame  = None,\n                         merge_key: Union[str,list] = None,\n                         intervention_bubbles: bool = False,\n                         intervention_bubble_names: Union[str,list] = None,\n                         save: str = None):\n\"\"\"Creates a chloropleth map of the specified intervention and time period for the optimal variable. \n        If more than one intervention is specified, then aggregates them. If more than one time period is specified, then creates a subplots of len(time) and show each.\n\n        Args:\n            intervention (str, optional): intervention to use. Defaults to None.\n            time (Union[int,list], optional): time periods to plot. Defaults to None.\n            optimum_interest (str, optional): optimal variable to use (Options include: 'b' for optimal benefits, 'c' for optimal costs, and 'v' for optimal variable). Defaults to 'b'.\n            map_df (geopandas.GeoDataFrame, optional): geopandas dataframe with geometry information. Defaults to None.\n            merge_key (Union[str,list], optional): column to merge geo-dataframe. Defaults to None.\n            intervention_bubbles (bool, optional): whether to show optimal intervention names in map. Defaults to False.\n            intervention_bubble_names (Union[str,list], optional): key to merge on to geo dataframe. Defaults to None.\n            save (str, optional): path to save map. Defaults to None.\n\n        Raises:\n            Exception: Not one of the allowed variables for map plotting\n        \"\"\"\n\n\n        if intervention is None:\n            intervention = self.optimal_interventions\n\n        p = Plotter(self)\n\n        if optimum_interest == 'b':\n            opt = 'opt_benefit'\n            title = self.benefit_title\n        elif optimum_interest == 'c':\n            opt = 'opt_costs'\n            title = \"Optimal Costs\"\n        elif optimum_interest == 'v':\n            opt = 'opt_vals'\n            title = \"Optimal Interventions\"\n        elif optimum_interest == 'cdb':\n            opt = 'cumulative_discounted_benefits'\n            title = 'Cumulative Discounted ' + self.benefit_title\n        elif optimum_interest == 'cdc':\n            opt = 'cumulative_discounted_costs'\n            title = 'Cumulative Discounted Costs'\n        elif optimum_interest == 'cb':\n            opt = 'cumulative_benefits'\n            title = 'Cumulative ' + self.benefit_title      \n        elif optimum_interest == 'cc':\n            opt = 'cumulative_costs'\n            title = 'Cumulative Costs'\n        else:\n            raise Exception(\"Not one of the allowed variables for map plotting. Try again.\")\n\n\n        plotter = p._plot_chloropleth_getter(time = time)\n        plot = plotter(data = self.opt_df,\n                                          intervention = intervention,\n                                            time = time,\n                                            optimum_interest=opt,\n                                            map_df = map_df,\n                                            merge_key=merge_key,\n                                            aggfunc = 'sum',\n                                            title = title,\n                                            intervention_bubbles = intervention_bubbles,\n                                            intervention_bubble_names = intervention_bubble_names,\n                                            save = save)\n        # return plot\n\n\n    def plot_grouped_interventions(self, \n                                    data_of_interest: str = 'benefits', \n                                    title: str = None,\n                                    intervention_subset: Union[str,list] = slice(None),\n                                    save: str = None):\n\"\"\"Shows Optimal level of benefits or costs in a grouped bar plots for every optimally chosen variable across regions.\n\n        Args:\n            data_of_interest (str, optional): variable to show. Defaults to 'benefits'.\n            title (str, optional):title for resulting plot. Defaults to None.\n            intervention_subset (Union[str,list], optional): subset of interventions to show on bar plot. Defaults to slice(None).\n            save (str, optional): path to save the figure. Defaults to None.\n        \"\"\"\n\n\n        p = Plotter(self)\n\n        if data_of_interest == 'benefits':\n            col_of_interest = 'opt_benefit'\n        elif data_of_interest == 'costs':\n            col_of_interest = 'opt_costs'\n\n        p._plot_grouped_bar(intervention_col= self.intervention_col,\n                            space_col = self.space_col,\n                            col_of_interest= col_of_interest,\n                            ylabel = \"Optimal Level\",\n                            intervention_subset= intervention_subset,\n                            save = save)\n\n\n\n    def plot_map_benchmark(self,\n                           intervention: list = None,\n                           time: list = None,\n                           optimum_interest: str = 'b',\n                           bench_intervention: list = None,\n                           map_df: gpd.GeoDataFrame = None,\n                           merge_key: Union[str,list] = None,\n                           save: str = None,\n                           intervention_in_title: bool = True,\n                           intervention_bubbles: bool = False,\n                           intervention_bubble_names: Union[str,list] = None,\n                           millions: bool = True,\n                           bau_intervention_bubble_names: Union[str,list] = None\n                           ):\n\"\"\"Maps the optimal level on a map against a benchmark, optionally the BAU level chosen from ``minimum_benefit`` or ``total_funds``.\n\n        Args:\n            intervention (list, optional): interventions to map. Defaults to None.\n            time (list, optional): time periods to map. Defaults to None.\n            optimum_interest (str, optional):  optimal value to use. Options include 'b' (benefits), 'c' (costs), 'v' (variables). Defaults to 'b'.\n            bench_intervention (list, optional): interventions to use for benchmark. Defaults to None.\n            map_df (geopandas.GeoDataFrame, optional):  geo dataframe with geometry data. Defaults to None.\n            merge_key (Union[str,list], optional): key to merge data from opt_df to geo dataframe. Defaults to None.\n            save (str, optional): path to save the map. Defaults to None.\n            intervention_in_title (bool, optional): True if intervention name will be included in the title of the figure. Defaults to True.\n            intervention_bubbles (bool, optional): True if intervention bubbles. Defaults to False.\n            intervention_bubble_names (Union[str,list], optional): names of intervention bubbles. Defaults to None.\n            millions (bool, optional): True if values displayed in millions. Defaults to True.\n            bau_intervention_bubble_names (Union[str,list], optional): name for bau intervention bubble. Defaults to None.\n\n        \"\"\"\n\n        if intervention is None:\n            intervention = self.optimal_interventions   \n\n        if figsize is not None:   \n            fig = plt.figure(figsize=figsize)\n        else:\n            fig = plt.figure(figsize=(10,12))\n\n        gs = gridspec.GridSpec(2,2, height_ratios = [6,1])\n        optimal = fig.add_subplot(gs[0,0])\n        bench = fig.add_subplot(gs[0,1])\n        cbar = fig.add_subplot(gs[1,:])\n\n        p = Plotter(self)\n\n        if optimum_interest == 'b':\n            opt = 'opt_benefit'\n            bench_col = self.benefit_col\n            title = self.benefit_title\n        elif optimum_interest == 'c':\n            opt = 'opt_costs'\n            bench_col = self.cost_col\n            title = \"Costs\"\n        elif optimum_interest == 'v':\n            opt = 'opt_vals'\n            title = \"Interventions\"\n        elif optimum_interest == 'cdb':\n            opt =  'cumulative_discounted_benefits'\n            bench_col = 'discounted_benefits'\n            title = 'Cumulative Discounted ' + self.benefit_title\n        elif optimum_interest == 'cdc':\n            opt =  'cumulative_discounted_costs'\n            title = 'Cumulative Discounted Costs'\n            bench_col = 'discounted_costs'\n        elif optimum_interest == 'cb':\n            opt =  'cumulative_benefits'\n            title = 'Cumulative ' + self.benefit_title   \n            bench_col = self.benefit_col   \n        elif optimum_interest == 'cc':\n            opt =  'cumulative_costs'\n            title = 'Cumulative Costs'\n            bench_col = self.cost_col\n        else:\n            raise Exception(\"Not one of the allowed variables for map plotting. Try again.\")\n\n        if bench_intervention is None:\n            bench_intervention = self.minimum_benefit\n\n        if merge_key is None:\n            merge_key = self.space_col\n\n        if optimum_interest in ['cdb', 'cdc', 'cb', 'cc']:\n\n            bench_df = self.bau_df.assign(bench_col = lambda df: (df\n                                                            .groupby([self.intervention_col, \n                                                                    self.space_col])\n                                                            [bench_col]\n                                                            .transform('cumsum')))\n\n        else:\n            bench_df = self.bau_df.assign(bench_col = lambda df: df[bench_col])\n\n        y = 1.05\n\n        if intervention_in_title:\n            title = title + f\"\\nOptimal Interventions:\\n{', '.join(intervention)}\"\n            y = y + .05\n\n        fig.suptitle(title, y=y)\n        plotter = p._plot_chloropleth_getter(time)\n\n        # Get min and max values for color map\n        opt_max = self.opt_df[opt].max()\n        opt_min = self.opt_df[opt].min()\n\n        bench_max = bench_df['bench_col'].max()\n        bench_min = bench_df['bench_col'].min()\n\n        vmax = max(opt_max, bench_max)\n        vmin = min(opt_min, bench_min)\n\n        if intervention_bubbles:\n            bau_intervention_bubbles = 'bau'\n        else:\n            bau_intervention_bubbles = False\n\n\n        plotter(data = self.opt_df,\n                    intervention = intervention,\n                    time = time,\n                    optimum_interest=opt,\n                    map_df = map_df,\n                    merge_key=merge_key,\n                    aggfunc = 'sum',\n                    ax = optimal,\n                    cax = cbar,\n                    title = \"Optimal Scenario\",\n                    intervention_bubbles = intervention_bubbles,\n                    intervention_bubble_names = intervention_bubble_names,\n                    vmin = vmin,\n                    vmax = vmax,\n                    legend_kwds = {'orientation' : 'horizontal'})\n\n        plotter(data = bench_df,\n                        intervention = bench_intervention,\n                        time = time,\n                        optimum_interest= 'bench_col',\n                        map_df = map_df,\n                        merge_key=merge_key,\n                        aggfunc = 'sum',\n                        ax = bench,\n                        show_legend = False,\n                        title = f\"BAU* Scenario\",\n                         vmin = vmin,\n                        vmax = vmax,\n                        intervention_bubbles = bau_intervention_bubbles,\n                        intervention_bubble_names = bau_intervention_bubble_names)\n\n        plt.tight_layout()\n\n        fig_text = 'Note: Colors describe ' + title\n\n        if millions:\n            fig_text = fig_text + ' (in millions)'\n\n        # if intervention_bubble_names:\n        #     fig_text = fig_text + '\\nBAU* scenario made up of ' + ', '.join(intervention_bubble_names)\n\n        fig.text(0.5,-.05, fig_text, ha='center')\n\n        if save is not None:\n            plt.savefig(save, dpi = p.dpi, bbox_inches=\"tight\")\n\n    @classmethod  \n    def supply_curve(cls, data, \n                    full_population,\n                    bau,\n                    all_space,\n                    all_time,\n                    time_subset,\n                    benefit_col='effective_coverage',\n                    cost_col='cost',\n                    intervention_col='intervention',\n                    space_col='space',\n                    time_col='time',\n                    ec_range=None,\n                    above_ul = False,\n                    above_ul_col = None,\n                    **kwargs): \n\n        if ec_range is None:\n            ec_range = np.arange(.1,1,.1)\n\n        if above_ul and above_ul_col is None:\n            above_ul_col = 'above_ul'\n\n\n        ratio_to_constraint = lambda ratio: ratio*full_population\n\n        model_dict = {}\n\n        for _, benefit_constraint in enumerate([bau] + list(ec_range)):\n\n            if isinstance(benefit_constraint, str):\n                minimum_benefit = benefit_constraint\n            else:\n                minimum_benefit = ratio_to_constraint(benefit_constraint)\n\n            c = cls(minimum_benefit = minimum_benefit,\n                        data = data, \n                        benefit_col = benefit_col,\n                        cost_col = cost_col,\n                        intervention_col = intervention_col,\n                        space_col = space_col,\n                        time_col = time_col,\n                        all_space =all_space, \n                        all_time = all_time,\n                        time_subset = time_subset,\n                        **kwargs)\n\n            opt = c.fit()\n\n            model_dict[benefit_constraint] = opt\n\n        results_dict = {'benefit' : [],\n                        'opt_benefits' : [],\n                        'opt_costs' : [],\n                        'opt_interventions' : [],\n                        'convergence' : [],\n                        'vas_regions' : []}\n        if above_ul:\n            results_dict['opt_above_ul'] = []\n            data = data.set_index([intervention_col,space_col,time_col])\n\n        for benefit_constraint, model in model_dict.items():\n\n            model.report(quiet=True)\n            results_dict['benefit'].append(benefit_constraint)\n            results_dict['opt_benefits'].append(model.opt_df.opt_benefit_discounted.sum())\n            results_dict['opt_costs'].append(model.opt_df.opt_costs_discounted.sum())\n            results_dict['opt_interventions'].append(model.optimal_interventions)\n            results_dict['convergence'].append(model.status)\n            results_dict['vas_regions'].append(model.opt_df\n                                               .query(\"opt_vals &gt; 0\")\n                                               .query(\"index.get_level_values('intervention').str.contains('vas', case=False)\")\n                                               .index.get_level_values('region').unique().values.tolist())\n\n            if above_ul:\n                above_ul_df = (\n                        data[above_ul_col]\n                        # .reset_index()\n                        # # .assign(intervention = lambda df: df[intervention_col].str.lower())\n                        # .set_index([intervention_col, space_col, time_col])\n                        )\n\n                opt_above_ul = (model.opt_df['opt_vals'] * above_ul_df).sum()\n\n                results_dict['opt_above_ul'].append(opt_above_ul)\n\n        return SupplyCurve(pd.DataFrame(results_dict, index=[results_dict['opt_benefits'][0]/full_population] + list(ec_range)) \n                           , full_population=full_population,\n                           bau=bau,\n                           data=data,\n                           ec_range=ec_range,\n                           intervention_col = intervention_col,\n                           space_col=space_col,\n                           time_col = time_col,\n                           cost_col=cost_col,\n                           benefit_col=benefit_col)        \n\n\n    @classmethod      \n    def plot_supply_curve(cls, \n                        supply_curve: SupplyCurve = None,\n                          data: DataFrame = None, \n                    full_population: Union[int, float] = None,\n                    bau: str=None,\n                    all_space: List[float]=None,\n                    all_time=None,\n                    time_subset=None,\n                    benefit_col='effective_coverage',\n                    cost_col='cost',\n                    intervention_col='intervention',\n                    space_col='space',\n                    time_col='time',\n                    ec_range=None,\n                    above_ul = False,\n                    above_ul_col = None,\n                    ec_thousands = 1_000,\n                    ul_thousands = 1_000,\n                    save=None,\n                    subplot_multiple=10,\n                    **kwargs):\n\n        if supply_curve is None:\n            supply_curve = cls.supply_curve(\n                        data=data, \n                        full_population=full_population,\n                        bau=bau,\n                        all_space=all_space,\n                        all_time=all_time,\n                        time_subset=time_subset,\n                        benefit_col=benefit_col,\n                        cost_col=cost_col,\n                        intervention_col=intervention_col,\n                        space_col=space_col,\n                        time_col=time_col,\n                        ec_range=ec_range,\n                        above_ul = above_ul,\n                        above_ul_col=above_ul_col\n                        **kwargs\n                        )\n\n        N_ec = len(supply_curve.ec_range)\n        full_population = supply_curve.full_population\n        bau = supply_curve.bau\n        data=supply_curve.data\n        sc = supply_curve.supply_curve # Now that we have all info. make `supply_curve` just the dataframe\n\n        # make nan of infeasible solutions\n        sc = sc.replace(0, np.nan)\n\n        only_bau_opt = sc.query(\"benefit == @bau\")\n\n        # # get places where interventions change\n        # transitions = supply_curve[~(supply_curve['opt_interventions'] == supply_curve['opt_interventions'].shift(-1))]\n\n        def start_from_bau(df):\n            df = df.loc[lambda df: df.index &gt;= only_bau_opt.index.values[0]]\n            if df.empty:\n                raise SupplyCurveTransitionException(\"All transitions less than BAU. Try increasing the number of points in ec_range\")\n\n            return df\n\n\n        # Now get additions of interventions by converting to set and doing difference\n        sc = (\n            sc\n            .dropna()\n            .assign(opt_interventions = lambda df: df['opt_interventions'].apply(lambda x: [i.split(' + ') for i in x]))\n            .assign(opt_interventions = lambda df: df['opt_interventions'].apply(lambda x: reduce(lambda y, z: y + z, x)))\n            .assign(opt_interventions = lambda df: df['opt_interventions'].apply(lambda x: set(x)))\n            .assign(int_transitions_lag = lambda df: df['opt_interventions'].shift(-1))\n            .dropna()\n            .assign(transitions_plus = lambda df: df.apply(lambda col: col['int_transitions_lag'].difference(col['opt_interventions']), axis=1).shift(1).fillna(df['opt_interventions']))\n            .assign(transitions_minus = lambda df: df.apply(lambda col: col['opt_interventions'].difference(col['int_transitions_lag']), axis=1).shift(1).fillna(df['opt_interventions']))\n            .query(\"benefit != @bau\")\n            # .pipe(start_from_bau)\n            )\n\n        if above_ul:\n            subplot_col = 2\n        else:\n            subplot_col = 1\n\n        with plt.style.context('seaborn-whitegrid'):\n            fig, ax = plt.subplots(subplot_col+1, 1, figsize=(subplot_multiple*subplot_col,12))\n\n\n            if above_ul:\n                ax0 = ax[0]\n                ax1 = ax[1]\n                ax_region=ax[2]\n            else:\n                ax0 = ax[0]\n                ax_region=ax[1]\n\n            sc['opt_costs'].plot(ax=ax0)\n\n            ax0.set_xlabel('Effective Coverage (%)')\n\n            ax0.set_xticks(sc.index.tolist())\n\n            ax0.set_xticklabels([f\"{x*100:.0f}\" for x in sc.index.tolist()])\n\n            ax0.ticklabel_format(axis='y', useMathText=True)\n\n            ax0.yaxis.set_major_formatter(tick.FuncFormatter(lambda y, _: f\"{y/ec_thousands:,.0f}\"))\n\n            ax0.set_title(f'Total Cost (x {ec_thousands:,.0f})')\n\n            if bau is not None:\n                if data is None:\n                    raise Exception(\"If `bau` is specified, `data` must also be specified\")\n\n                if len(data.index.names) == 1:\n                    data = data.set_index([supply_curve.intervention_col,\n                                           supply_curve.space_col,\n                                           supply_curve.time_col])\n\n                bau_ec, bau_costs = BAUConstraintCreator().bau_df(data, bau, [supply_curve.benefit_col,\n                                                                              supply_curve.cost_col]).sum()\n\n                ax0.scatter(bau_ec/full_population, bau_costs, color='tab:green', marker='s')\n                ax0.annotate(\"BAU\", (bau_ec/full_population, bau_costs), xytext=(5, 5),  \n                            textcoords=\"offset pixels\", color='black')\n\n            opt_b, opt_c = only_bau_opt[['opt_benefits', 'opt_costs']].values.tolist()[0]\n\n            ax0.annotate(\"Optimum\", (opt_b/full_population, opt_c), xytext=(5, -10),  \n                        textcoords=\"offset pixels\", color='black')\n            ax0.scatter(opt_b/full_population, opt_c,  color='tab:orange', marker=\"s\")\n\n            if above_ul:\n                try:\n                    sc[above_ul_col]\n                except KeyError:\n                    raise Exception(f\"No above ul in the data\")\n                # Now get above_ul\n                sc['opt_above_ul'].plot(ax=ax1, color='tab:red')\n                ax1.yaxis.set_major_formatter(tick.FuncFormatter(lambda y, _: f\"{y/ul_thousands:,.0f}\"))\n                ax1.set_title(f'Population Above UL (x {ul_thousands:,.0f})')\n                ax1.set_xticks(sc.index.tolist())\n                ax1.set_xticklabels([f\"{x*100:.0f}\" for x in sc.index.tolist()])\n                ax1.set_xlabel('Effective Coverage (%)')\n\n            def message_writer(x):\n                if len(x['transitions_plus']) != 0 and len(x['transitions_minus'])!=0:\n                    message= \"+ \" + ', '.join(x['transitions_plus']) +  \" - \" + \", \".join(x['transitions_minus'])\n                    message = '\\n'.join(textwrap.wrap(message, width=50))\n\n                    # ns_needed = len(message)//25\n\n                    # # for i in range(ns_needed):\n                    # #     message = message[i*25:i+25] + r'-len\\n' + message[25+1+i:]\n\n                    return message\n\n            # print(sc)\n\n\n            (\n                sc['vas_regions']\n                .explode()\n                .to_frame()\n                .assign(yes=lambda df: \\\n                    (~df['vas_regions'].isnull())\n                    .astype(int))\n                .set_index('vas_regions', \n                           append=True)\n                .unstack()\n                # .drop(columns=('yes', pd.NA))\n                .plot.bar(stacked=True, legend=False, \n                          ax=ax_region, cmap='tab20')\n                )\n\n            # ax_region.set_xticks(sc.index.tolist())\n            ax_region.set_xticklabels([f\"{x*100:.0f}\" for x in sc.index.tolist()],\n                                      rotation=0)\n            ax_region.set_xlabel('Effective Coverage (%)')\n            ax_region.set_yticklabels([])\n            ax_region.set_title(\"VAS Regions\")\n\n            texts = (\n                sc\n                .assign(message = lambda df: df.apply(lambda x: message_writer(x), axis=1))\n                .apply(lambda df: ax0.text(df.name+.01, df['opt_costs'], \n                                                s=df['message'],\n                                                color='black', wrap=True), axis=1) \n                .values.tolist()\n                )   \n\n            # adjust_text(texts, arrowprops=dict(arrowstyle='-&gt;', color='green'))\n\n            figtext = f\"Note: BAU refers to a nutritional intervention of {bau.title()}.\" \\\n            f\" Optimum solution consists of {', '.join(only_bau_opt['opt_interventions'].values[0])}.\" \\\n            \" Vitamin A Supplementation taking place at various level of effective coverage in: \" \\\n                           f\"{', '.join(list(set(np.concatenate(sc['vas_regions'].values))))}\"\n\n            txt = fig.text(.05, -.1, s='\\n'.join(textwrap.wrap(figtext, width=100)))\n\n            handles, labels = ax_region.get_legend_handles_labels()\n\n            new_labels = [i.split(',')[1].replace(')', '').strip() for i in labels]\n            plt.legend(handles, new_labels, ncol=4, loc='lower center', \n                       bbox_to_anchor = (.5,-.6),\n                       title='Regions')                 \n\n            plt.tight_layout()\n\n            if save is not None:\n                plt.savefig(save, dpi=300, bbox_inches='tight')\n\n        return ax\n</code></pre>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver.bau_list","title":"<code>bau_list: pd.DataFrame</code>  <code>property</code>","text":"<p>Returns a dataframe with the name of the bau intervention. Mostly done for compatibility with other methods.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: dataframe with the name of the bau intervention</p>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver.__init__","title":"<code>__init__(data, benefit_col='benefits', cost_col='costs', intervention_col='intervention', space_col='space', time_col='time', interest_rate_cost=0.0, interest_rate_benefit=0.03, va_weight=1.0, sense=None, solver_name=mip.CBC, show_output=True, benefit_title='Benefits')</code>","text":"<p>The base solver for the Optimization. This sets up the basic setup of the model, which includes: - data handling - BAU constraint creation - base model constraint creation</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>dataframe with benefits and cost data.</p> required <code>benefit_col</code> <code>str</code> <p>name of dataframe's column with benefit data. Defaults to 'benefits'.</p> <code>'benefits'</code> <code>cost_col</code> <code>str</code> <p>name of dataframe's column with cost data. Defaults to 'costs'.</p> <code>'costs'</code> <code>intervention_col</code> <code>str</code> <p>name of dataframe's column with intervention data. Defaults to 'intervention'.</p> <code>'intervention'</code> <code>space_col</code> <code>str</code> <p>name of dataframe's column with space/region data . Defaults to 'space'.</p> <code>'space'</code> <code>time_col</code> <code>str</code> <p>name of dataframe's column with time period data . Defaults to 'time'.</p> <code>'time'</code> <code>interest_rate_cost</code> <code>float</code> <p>interest rate of costs. Defaults to 0.0.</p> <code>0.0</code> <code>benefit_title</code> <code>str</code> <p>title for benefits to use in plots and reports. Defaults to \"Benefits\".</p> <code>'Benefits'</code> <p><code>BaseSolver</code> is inherited by <code>CostSolver</code> and <code>BenefitSolver</code> to then run optimizations.</p> Source code in <code>minimod_opt/base/basesolver.py</code> <pre><code>def __init__(\n    self,\n    data: pd.DataFrame,\n    benefit_col: str = 'benefits',\n    cost_col: str = 'costs',\n    intervention_col: str = 'intervention',\n    space_col: str = 'space',\n    time_col: str = 'time',\n    interest_rate_cost: float = 0.0,  # Discount factor for costs\n    interest_rate_benefit: float = 0.03,  # Discount factor for benefits \n    va_weight: float = 1.0,  # VA Weight\n    sense: str = None,  # MIP optimization type (maximization or minimization)\n    solver_name: str = mip.CBC,  # Solver for MIP to use\n    show_output: bool = True,\n    benefit_title: str = \"Benefits\",\n):       \n\n\"\"\"The base solver for the Optimization. This sets up the basic setup of the model, which includes:\n    - data handling\n    - BAU constraint creation\n    - base model constraint creation\n\n    Args:\n            data (pd.DataFrame): dataframe with benefits and cost data.\n            benefit_col (str, optional): name of dataframe's column with benefit data. Defaults to 'benefits'.\n            cost_col (str, optional): name of dataframe's column with cost data. Defaults to 'costs'.\n            intervention_col (str, optional): name of dataframe's column with intervention data. Defaults to 'intervention'.\n            space_col (str, optional): name of dataframe's column with space/region data . Defaults to 'space'.\n            time_col (str, optional): name of dataframe's column with time period data . Defaults to 'time'.\n            interest_rate_cost (float, optional): interest rate of costs. Defaults to 0.0.\n            benefit_title (str, optional): title for benefits to use in plots and reports. Defaults to \"Benefits\".\n\n    ``BaseSolver`` is inherited by ``CostSolver`` and ``BenefitSolver`` to then run optimizations.\n    \"\"\"        \n\n    self.interest_rate_cost = interest_rate_cost\n    self.interest_rate_benefit = interest_rate_benefit\n    self.va_weight = va_weight\n    self.discount_costs = 1 / (1 + self.interest_rate_cost)\n    self.discount_benefits = 1 / (1 + self.interest_rate_benefit)\n    self.benefit_title = benefit_title\n\n    if sense is not None:\n        self.sense = sense\n    else:\n        raise Exception(\"No Optimization Method was specified\")\n\n    self.solver_name = solver_name\n    self.show_output = show_output\n\n    # Process Data\n\n    if self.show_output:\n        print(\"[Note]: Processing Data...\")\n\n    self._df = self._process_data(\n        data=data,\n        intervention=intervention_col,\n        space=space_col,\n        time=time_col,\n        benefits=benefit_col,\n        costs=cost_col,\n    )\n\n\n    self.benefit_col = benefit_col\n    self.cost_col = cost_col\n    self.intervention_col = intervention_col\n    self.space_col = space_col\n    self.time_col = time_col\n\n    if self.show_output:\n        print(\"[Note]: Creating Base Model with constraints\")\n\n\n    self.minimum_benefit = None\n    self.total_funds = None\n\n    self.message = f\"\"\"\n            MiniMod Nutrition Intervention Tool\n            Optimization Method: {str(self.sense)}\n            Solver: {str(self.solver_name)},\n            Show Output: {self.show_output}\n\n            \"\"\"\n\n    if self.show_output:\n        print(self.message)\n</code></pre>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver.plot_bau_time","title":"<code>plot_bau_time(opt_variable='b', fig=None, ax=None, save=None)</code>","text":"<p>Plots benefits and costs of optimal and benchark interventions across time </p> <p>Parameters:</p> Name Type Description Default <code>opt_variable</code> <code>str</code> <p>optimal variable to be plotted, where b = optimal benefits c = 'optimal costs cdb = cumulative discounted benefits cdc = cumulative discounted costs cb = cumulative benefits cc = cumulative costs</p> <code>'b'</code> <code>fig</code> <code>matplotlib.figure</code> <p>matplotlib figure. Defaults to None.</p> <code>None</code> <code>ax</code> <code>matplotlib.axis</code> <p>matplotlib axis to use. Defaults to None.</p> <code>None</code> <code>save</code> <code>str</code> <p>path to save the figure. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>not one of the allowed variables for map plotting</p> Source code in <code>minimod_opt/base/basesolver.py</code> <pre><code>def plot_bau_time(self,\n                  opt_variable: str = 'b',\n                  fig: mpl.figure = None,\n                  ax: mpl.axis = None,\n                  save: str = None):\n\"\"\"Plots benefits and costs of optimal and benchark interventions across time \n\n    Args:\n        opt_variable (str, optional): optimal variable to be plotted, where\n            b = optimal benefits\n            c = 'optimal costs\n            cdb = cumulative discounted benefits\n            cdc = cumulative discounted costs\n            cb = cumulative benefits\n            cc = cumulative costs\n        Defaults to 'b'.\n        fig (matplotlib.figure, optional): matplotlib figure. Defaults to None.\n        ax (matplotlib.axis, optional):matplotlib axis to use. Defaults to None.\n        save (str, optional): path to save the figure. Defaults to None.\n\n    Raises:\n        Exception: not one of the allowed variables for map plotting\n    \"\"\"\n\n    if ax is None:\n        fig, ax = plt.subplots()\n\n    p = Plotter(self)\n\n    if opt_variable == 'b':\n        opt = 'opt_benefit'\n        bau_col = self.benefit_col\n        title = \"Optimal \" + self.benefit_title + \" vs. BAU\"\n    elif opt_variable == 'c':\n        opt = 'opt_costs'\n        bau_col = self.cost_col\n        title = \"Optimal Costs vs. BAU\"\n    elif opt_variable == 'cdb':\n        opt = 'cumulative_discounted_benefits'\n        bau_col = 'discounted_benefits'\n        title = 'Cumulative Discounted ' + self.benefit_title\n    elif opt_variable == 'cdc':\n        opt = 'cumulative_discounted_costs'\n        bau_col = 'discounted_costs'\n        title = 'Cumulative Discounted Costs'\n    elif opt_variable == 'cb':\n        opt = 'cumulative_benefits'\n        bau_col = self.benefit_col\n        title = 'Cumulative ' + self.benefit_title      \n    elif opt_variable == 'cc':\n        opt = 'cumulative_costs'\n        bau_col = self.cost_col\n        title = 'Cumulative Costs'\n    else:\n        raise Exception(\"Not one of the allowed variables for map plotting. Try again.\")\n\n    if opt_variable in ['cdb', 'cdc', 'cb', 'cc']:\n\n        bench_df = (\n            self.bau_df\n            .groupby([self.time_col])\n            .sum().cumsum()\n            .assign(bench_col = lambda df: df[bau_col])\n            )\n\n    else:\n        bench_df = (\n            self.bau_df\n            .assign(bench_col = lambda df: df[bau_col])\n            .groupby([self.time_col])\n            .sum()\n                    )\n\n    p._plot_lines(to_plot = opt,\n                title= title,\n                xlabel = 'Time',\n                figure=fig,\n                axis=ax)\n\n    bench_df['bench_col'].plot(ax=ax)\n\n    ax.legend(['Optimal', 'BAU'])\n    ax.set_xlabel('Time')\n\n    if save is not None:\n        plt.savefig(save)\n</code></pre>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver.plot_chloropleth","title":"<code>plot_chloropleth(intervention=None, time=None, optimum_interest='b', map_df=None, merge_key=None, intervention_bubbles=False, intervention_bubble_names=None, save=None)</code>","text":"<p>Creates a chloropleth map of the specified intervention and time period for the optimal variable.  If more than one intervention is specified, then aggregates them. If more than one time period is specified, then creates a subplots of len(time) and show each.</p> <p>Parameters:</p> Name Type Description Default <code>intervention</code> <code>str</code> <p>intervention to use. Defaults to None.</p> <code>None</code> <code>time</code> <code>Union[int, list]</code> <p>time periods to plot. Defaults to None.</p> <code>None</code> <code>optimum_interest</code> <code>str</code> <p>optimal variable to use (Options include: 'b' for optimal benefits, 'c' for optimal costs, and 'v' for optimal variable). Defaults to 'b'.</p> <code>'b'</code> <code>map_df</code> <code>geopandas.GeoDataFrame</code> <p>geopandas dataframe with geometry information. Defaults to None.</p> <code>None</code> <code>merge_key</code> <code>Union[str, list]</code> <p>column to merge geo-dataframe. Defaults to None.</p> <code>None</code> <code>intervention_bubbles</code> <code>bool</code> <p>whether to show optimal intervention names in map. Defaults to False.</p> <code>False</code> <code>intervention_bubble_names</code> <code>Union[str, list]</code> <p>key to merge on to geo dataframe. Defaults to None.</p> <code>None</code> <code>save</code> <code>str</code> <p>path to save map. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Not one of the allowed variables for map plotting</p> Source code in <code>minimod_opt/base/basesolver.py</code> <pre><code>def plot_chloropleth(self,\n                     intervention: str = None,\n                     time: Union[int,list] = None,\n                     optimum_interest: str = 'b',\n                     map_df: gpd.GeoDataFrame  = None,\n                     merge_key: Union[str,list] = None,\n                     intervention_bubbles: bool = False,\n                     intervention_bubble_names: Union[str,list] = None,\n                     save: str = None):\n\"\"\"Creates a chloropleth map of the specified intervention and time period for the optimal variable. \n    If more than one intervention is specified, then aggregates them. If more than one time period is specified, then creates a subplots of len(time) and show each.\n\n    Args:\n        intervention (str, optional): intervention to use. Defaults to None.\n        time (Union[int,list], optional): time periods to plot. Defaults to None.\n        optimum_interest (str, optional): optimal variable to use (Options include: 'b' for optimal benefits, 'c' for optimal costs, and 'v' for optimal variable). Defaults to 'b'.\n        map_df (geopandas.GeoDataFrame, optional): geopandas dataframe with geometry information. Defaults to None.\n        merge_key (Union[str,list], optional): column to merge geo-dataframe. Defaults to None.\n        intervention_bubbles (bool, optional): whether to show optimal intervention names in map. Defaults to False.\n        intervention_bubble_names (Union[str,list], optional): key to merge on to geo dataframe. Defaults to None.\n        save (str, optional): path to save map. Defaults to None.\n\n    Raises:\n        Exception: Not one of the allowed variables for map plotting\n    \"\"\"\n\n\n    if intervention is None:\n        intervention = self.optimal_interventions\n\n    p = Plotter(self)\n\n    if optimum_interest == 'b':\n        opt = 'opt_benefit'\n        title = self.benefit_title\n    elif optimum_interest == 'c':\n        opt = 'opt_costs'\n        title = \"Optimal Costs\"\n    elif optimum_interest == 'v':\n        opt = 'opt_vals'\n        title = \"Optimal Interventions\"\n    elif optimum_interest == 'cdb':\n        opt = 'cumulative_discounted_benefits'\n        title = 'Cumulative Discounted ' + self.benefit_title\n    elif optimum_interest == 'cdc':\n        opt = 'cumulative_discounted_costs'\n        title = 'Cumulative Discounted Costs'\n    elif optimum_interest == 'cb':\n        opt = 'cumulative_benefits'\n        title = 'Cumulative ' + self.benefit_title      \n    elif optimum_interest == 'cc':\n        opt = 'cumulative_costs'\n        title = 'Cumulative Costs'\n    else:\n        raise Exception(\"Not one of the allowed variables for map plotting. Try again.\")\n\n\n    plotter = p._plot_chloropleth_getter(time = time)\n    plot = plotter(data = self.opt_df,\n                                      intervention = intervention,\n                                        time = time,\n                                        optimum_interest=opt,\n                                        map_df = map_df,\n                                        merge_key=merge_key,\n                                        aggfunc = 'sum',\n                                        title = title,\n                                        intervention_bubbles = intervention_bubbles,\n                                        intervention_bubble_names = intervention_bubble_names,\n                                        save = save)\n</code></pre>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver.plot_grouped_interventions","title":"<code>plot_grouped_interventions(data_of_interest='benefits', title=None, intervention_subset=slice(None), save=None)</code>","text":"<p>Shows Optimal level of benefits or costs in a grouped bar plots for every optimally chosen variable across regions.</p> <p>Parameters:</p> Name Type Description Default <code>data_of_interest</code> <code>str</code> <p>variable to show. Defaults to 'benefits'.</p> <code>'benefits'</code> <code>title</code> <code>str</code> <p>title for resulting plot. Defaults to None.</p> <code>None</code> <code>intervention_subset</code> <code>Union[str, list]</code> <p>subset of interventions to show on bar plot. Defaults to slice(None).</p> <code>slice(None)</code> <code>save</code> <code>str</code> <p>path to save the figure. Defaults to None.</p> <code>None</code> Source code in <code>minimod_opt/base/basesolver.py</code> <pre><code>def plot_grouped_interventions(self, \n                                data_of_interest: str = 'benefits', \n                                title: str = None,\n                                intervention_subset: Union[str,list] = slice(None),\n                                save: str = None):\n\"\"\"Shows Optimal level of benefits or costs in a grouped bar plots for every optimally chosen variable across regions.\n\n    Args:\n        data_of_interest (str, optional): variable to show. Defaults to 'benefits'.\n        title (str, optional):title for resulting plot. Defaults to None.\n        intervention_subset (Union[str,list], optional): subset of interventions to show on bar plot. Defaults to slice(None).\n        save (str, optional): path to save the figure. Defaults to None.\n    \"\"\"\n\n\n    p = Plotter(self)\n\n    if data_of_interest == 'benefits':\n        col_of_interest = 'opt_benefit'\n    elif data_of_interest == 'costs':\n        col_of_interest = 'opt_costs'\n\n    p._plot_grouped_bar(intervention_col= self.intervention_col,\n                        space_col = self.space_col,\n                        col_of_interest= col_of_interest,\n                        ylabel = \"Optimal Level\",\n                        intervention_subset= intervention_subset,\n                        save = save)\n</code></pre>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver.plot_map_benchmark","title":"<code>plot_map_benchmark(intervention=None, time=None, optimum_interest='b', bench_intervention=None, map_df=None, merge_key=None, save=None, intervention_in_title=True, intervention_bubbles=False, intervention_bubble_names=None, millions=True, bau_intervention_bubble_names=None)</code>","text":"<p>Maps the optimal level on a map against a benchmark, optionally the BAU level chosen from <code>minimum_benefit</code> or <code>total_funds</code>.</p> <p>Parameters:</p> Name Type Description Default <code>intervention</code> <code>list</code> <p>interventions to map. Defaults to None.</p> <code>None</code> <code>time</code> <code>list</code> <p>time periods to map. Defaults to None.</p> <code>None</code> <code>optimum_interest</code> <code>str</code> <p>optimal value to use. Options include 'b' (benefits), 'c' (costs), 'v' (variables). Defaults to 'b'.</p> <code>'b'</code> <code>bench_intervention</code> <code>list</code> <p>interventions to use for benchmark. Defaults to None.</p> <code>None</code> <code>map_df</code> <code>geopandas.GeoDataFrame</code> <p>geo dataframe with geometry data. Defaults to None.</p> <code>None</code> <code>merge_key</code> <code>Union[str, list]</code> <p>key to merge data from opt_df to geo dataframe. Defaults to None.</p> <code>None</code> <code>save</code> <code>str</code> <p>path to save the map. Defaults to None.</p> <code>None</code> <code>intervention_in_title</code> <code>bool</code> <p>True if intervention name will be included in the title of the figure. Defaults to True.</p> <code>True</code> <code>intervention_bubbles</code> <code>bool</code> <p>True if intervention bubbles. Defaults to False.</p> <code>False</code> <code>intervention_bubble_names</code> <code>Union[str, list]</code> <p>names of intervention bubbles. Defaults to None.</p> <code>None</code> <code>millions</code> <code>bool</code> <p>True if values displayed in millions. Defaults to True.</p> <code>True</code> <code>bau_intervention_bubble_names</code> <code>Union[str, list]</code> <p>name for bau intervention bubble. Defaults to None.</p> <code>None</code> Source code in <code>minimod_opt/base/basesolver.py</code> <pre><code>def plot_map_benchmark(self,\n                       intervention: list = None,\n                       time: list = None,\n                       optimum_interest: str = 'b',\n                       bench_intervention: list = None,\n                       map_df: gpd.GeoDataFrame = None,\n                       merge_key: Union[str,list] = None,\n                       save: str = None,\n                       intervention_in_title: bool = True,\n                       intervention_bubbles: bool = False,\n                       intervention_bubble_names: Union[str,list] = None,\n                       millions: bool = True,\n                       bau_intervention_bubble_names: Union[str,list] = None\n                       ):\n\"\"\"Maps the optimal level on a map against a benchmark, optionally the BAU level chosen from ``minimum_benefit`` or ``total_funds``.\n\n    Args:\n        intervention (list, optional): interventions to map. Defaults to None.\n        time (list, optional): time periods to map. Defaults to None.\n        optimum_interest (str, optional):  optimal value to use. Options include 'b' (benefits), 'c' (costs), 'v' (variables). Defaults to 'b'.\n        bench_intervention (list, optional): interventions to use for benchmark. Defaults to None.\n        map_df (geopandas.GeoDataFrame, optional):  geo dataframe with geometry data. Defaults to None.\n        merge_key (Union[str,list], optional): key to merge data from opt_df to geo dataframe. Defaults to None.\n        save (str, optional): path to save the map. Defaults to None.\n        intervention_in_title (bool, optional): True if intervention name will be included in the title of the figure. Defaults to True.\n        intervention_bubbles (bool, optional): True if intervention bubbles. Defaults to False.\n        intervention_bubble_names (Union[str,list], optional): names of intervention bubbles. Defaults to None.\n        millions (bool, optional): True if values displayed in millions. Defaults to True.\n        bau_intervention_bubble_names (Union[str,list], optional): name for bau intervention bubble. Defaults to None.\n\n    \"\"\"\n\n    if intervention is None:\n        intervention = self.optimal_interventions   \n\n    if figsize is not None:   \n        fig = plt.figure(figsize=figsize)\n    else:\n        fig = plt.figure(figsize=(10,12))\n\n    gs = gridspec.GridSpec(2,2, height_ratios = [6,1])\n    optimal = fig.add_subplot(gs[0,0])\n    bench = fig.add_subplot(gs[0,1])\n    cbar = fig.add_subplot(gs[1,:])\n\n    p = Plotter(self)\n\n    if optimum_interest == 'b':\n        opt = 'opt_benefit'\n        bench_col = self.benefit_col\n        title = self.benefit_title\n    elif optimum_interest == 'c':\n        opt = 'opt_costs'\n        bench_col = self.cost_col\n        title = \"Costs\"\n    elif optimum_interest == 'v':\n        opt = 'opt_vals'\n        title = \"Interventions\"\n    elif optimum_interest == 'cdb':\n        opt =  'cumulative_discounted_benefits'\n        bench_col = 'discounted_benefits'\n        title = 'Cumulative Discounted ' + self.benefit_title\n    elif optimum_interest == 'cdc':\n        opt =  'cumulative_discounted_costs'\n        title = 'Cumulative Discounted Costs'\n        bench_col = 'discounted_costs'\n    elif optimum_interest == 'cb':\n        opt =  'cumulative_benefits'\n        title = 'Cumulative ' + self.benefit_title   \n        bench_col = self.benefit_col   \n    elif optimum_interest == 'cc':\n        opt =  'cumulative_costs'\n        title = 'Cumulative Costs'\n        bench_col = self.cost_col\n    else:\n        raise Exception(\"Not one of the allowed variables for map plotting. Try again.\")\n\n    if bench_intervention is None:\n        bench_intervention = self.minimum_benefit\n\n    if merge_key is None:\n        merge_key = self.space_col\n\n    if optimum_interest in ['cdb', 'cdc', 'cb', 'cc']:\n\n        bench_df = self.bau_df.assign(bench_col = lambda df: (df\n                                                        .groupby([self.intervention_col, \n                                                                self.space_col])\n                                                        [bench_col]\n                                                        .transform('cumsum')))\n\n    else:\n        bench_df = self.bau_df.assign(bench_col = lambda df: df[bench_col])\n\n    y = 1.05\n\n    if intervention_in_title:\n        title = title + f\"\\nOptimal Interventions:\\n{', '.join(intervention)}\"\n        y = y + .05\n\n    fig.suptitle(title, y=y)\n    plotter = p._plot_chloropleth_getter(time)\n\n    # Get min and max values for color map\n    opt_max = self.opt_df[opt].max()\n    opt_min = self.opt_df[opt].min()\n\n    bench_max = bench_df['bench_col'].max()\n    bench_min = bench_df['bench_col'].min()\n\n    vmax = max(opt_max, bench_max)\n    vmin = min(opt_min, bench_min)\n\n    if intervention_bubbles:\n        bau_intervention_bubbles = 'bau'\n    else:\n        bau_intervention_bubbles = False\n\n\n    plotter(data = self.opt_df,\n                intervention = intervention,\n                time = time,\n                optimum_interest=opt,\n                map_df = map_df,\n                merge_key=merge_key,\n                aggfunc = 'sum',\n                ax = optimal,\n                cax = cbar,\n                title = \"Optimal Scenario\",\n                intervention_bubbles = intervention_bubbles,\n                intervention_bubble_names = intervention_bubble_names,\n                vmin = vmin,\n                vmax = vmax,\n                legend_kwds = {'orientation' : 'horizontal'})\n\n    plotter(data = bench_df,\n                    intervention = bench_intervention,\n                    time = time,\n                    optimum_interest= 'bench_col',\n                    map_df = map_df,\n                    merge_key=merge_key,\n                    aggfunc = 'sum',\n                    ax = bench,\n                    show_legend = False,\n                    title = f\"BAU* Scenario\",\n                     vmin = vmin,\n                    vmax = vmax,\n                    intervention_bubbles = bau_intervention_bubbles,\n                    intervention_bubble_names = bau_intervention_bubble_names)\n\n    plt.tight_layout()\n\n    fig_text = 'Note: Colors describe ' + title\n\n    if millions:\n        fig_text = fig_text + ' (in millions)'\n\n    # if intervention_bubble_names:\n    #     fig_text = fig_text + '\\nBAU* scenario made up of ' + ', '.join(intervention_bubble_names)\n\n    fig.text(0.5,-.05, fig_text, ha='center')\n\n    if save is not None:\n        plt.savefig(save, dpi = p.dpi, bbox_inches=\"tight\")\n</code></pre>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver.plot_opt_val_hist","title":"<code>plot_opt_val_hist(fig=None, ax=None, save=None)</code>","text":"<p>A histogram of the optimally chosen interventions</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>matplotlib.figure</code> <p>figure instance to use. Defaults to None.</p> <code>None</code> <code>ax</code> <code>matplotlib.axis</code> <p>axis instance to use. Defaults to None.</p> <code>None</code> <code>save</code> <code>str</code> <p>path to save the figure. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>mpl.figure</code> <p>matplotlib.figure: histogram figure</p> Source code in <code>minimod_opt/base/basesolver.py</code> <pre><code>def plot_opt_val_hist(self, \n                      fig: mpl.figure = None, \n                      ax: mpl.axis = None, \n                      save: str = None) -&gt; mpl.figure:\n\"\"\"A histogram of the optimally chosen interventions\n\n    Args:\n        fig (matplotlib.figure, optional): figure instance to use. Defaults to None.\n        ax (matplotlib.axis, optional): axis instance to use. Defaults to None.\n        save (str, optional): path to save the figure. Defaults to None.\n\n    Returns:\n        matplotlib.figure: histogram figure\n    \"\"\"      \n\n    p = Plotter(self)\n\n    return p._plot_hist(to_plot = 'opt_vals',\n                        title = \"Optimal Choices\",\n                        xlabel = \"Time\",\n                        ylabel= \"\",\n                        figure = fig,\n                        axis = ax,\n                        save = save)  \n</code></pre>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver.plot_time","title":"<code>plot_time(fig=None, ax=None, save=None, cumulative=False, cumulative_discount=False)</code>","text":"<p>Plots optimal benefits and costs across time after model optimization</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>matplotlib.figure</code> <p>matplotlib figure. Defaults to None.</p> <code>None</code> <code>ax</code> <code>matplotlib.axis</code> <p>matplotlib axis to use. Defaults to None.</p> <code>None</code> <code>save</code> <code>str</code> <p>path to save the figure. Defaults to None.</p> <code>None</code> <code>cumulative</code> <code>bool</code> <p>whether to plot cumulative benefits or costs. Defaults to False.</p> <code>False</code> <code>cumulative_discount</code> <code>bool</code> <p>whether to plot cumulative benefits or costs, discounted. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>mpl.figure</code> <p>matplotlib.figure: figure with optimal benefits and cost across time</p> Source code in <code>minimod_opt/base/basesolver.py</code> <pre><code>def plot_time(self, \n              fig: mpl.figure = None, \n              ax: mpl.axis= None,\n              save: str = None,\n              cumulative: bool = False,\n              cumulative_discount: bool = False) -&gt; mpl.figure:\n\"\"\"Plots optimal benefits and costs across time after model optimization\n\n    Args:\n        fig (matplotlib.figure, optional): matplotlib figure. Defaults to None.\n        ax (matplotlib.axis, optional): matplotlib axis to use. Defaults to None.\n        save (str, optional): path to save the figure. Defaults to None.\n        cumulative (bool, optional): whether to plot cumulative benefits or costs. Defaults to False.\n        cumulative_discount (bool, optional): whether to plot cumulative benefits or costs, discounted. Defaults to False.\n\n    Returns:\n        matplotlib.figure: figure with optimal benefits and cost across time\n    \"\"\"\n\n    p = Plotter(self)\n\n    if cumulative:\n        return p._plot_lines(to_plot = ['cumulative_benefits', 'cumulative_costs'],\n                title= \"Optima over Time\",\n                xlabel = 'Time',\n                ylabel = self.benefit_title,\n                twin =True,\n                twin_ylabel= \"Currency\",\n                save = save,\n                legend = ['Cumm. ' + self.benefit_title,\n                        'Cumm. Costs'],\n                figure=fig,\n                axis=ax)\n    elif cumulative_discount:\n        return p._plot_lines(to_plot = ['cumulative_discounted_benefits', 'cumulative_discounted_costs'],\n                title= \"Optima over Time\",\n                xlabel = 'Time',\n                ylabel = self.benefit_title,\n                twin =True,\n                twin_ylabel= \"Currency\",\n                save = save,\n                legend = ['Cumm. Dis. '+ self.benefit_title,\n                        'Cumm. Dis. Costs'],\n                figure=fig,\n                axis=ax)\n    else:\n        return p._plot_lines(to_plot = ['opt_benefit', 'opt_costs'],\n                            title= \"Optima over Time\",\n                            xlabel = 'Time',\n                            ylabel = self.benefit_title,\n                            twin =True,\n                            twin_ylabel= \"Currency\",\n                            save = save,\n                            legend = ['Optimal ' + self.benefit_title,\n                                    'Optimal Costs'],\n                            figure=fig,\n                            axis=ax)\n</code></pre>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver.process_results","title":"<code>process_results(sol_num=None)</code>","text":"<p>Processes results of optimization to be used in visualization and reporting functions</p> <p>Parameters:</p> Name Type Description Default <code>sol_num</code> <code>int</code> <p>index of solution. Defaults to None.</p> <code>None</code> Source code in <code>minimod_opt/base/basesolver.py</code> <pre><code>def process_results(self, sol_num:int=None):\n\"\"\"Processes results of optimization to be used in visualization and reporting functions\n\n    Args:\n        sol_num (int, optional): index of solution. Defaults to None.\n    \"\"\"\n\n    self.opt_df = self.model.process_results(self.benefit_col, \n                                        self.cost_col, \n                                        self.intervention_col,\n                                        self.space_col,\n                                        sol_num=sol_num)\n</code></pre>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver.report","title":"<code>report(sol_num=None, quiet=False)</code>","text":"<p>Prints out a report of optimal model parameters and useful statistics.</p> <p>Parameters:</p> Name Type Description Default <code>sol_num</code> <code>int</code> <p>index of solution to be displayed. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>whether we want the report printed out or not. Defaults to False.</p> <code>False</code> Source code in <code>minimod_opt/base/basesolver.py</code> <pre><code>def report(self, sol_num:int=None, quiet:bool=False) -&gt; str:\n\"\"\"Prints out a report of optimal model parameters and useful statistics.\n\n    Args:\n        sol_num (int, optional): index of solution to be displayed. Defaults to None.\n        quiet (bool, optional): whether we want the report printed out or not. Defaults to False.\n    \"\"\"\n\n    self.opt_df = self.model.process_results(self.benefit_col, \n                                        self.cost_col, \n                                        self.intervention_col,\n                                        self.space_col,\n                                        sol_num=sol_num)\n\n    if quiet:\n        return\n    header = [\n        ('MiniMod Solver Results', \"\"),\n        (\"Method:\" , str(self.sense)),\n        (\"Solver:\", str(self.solver_name)),\n        (\"Optimization Status:\", str(self.status)),\n        (\"Number of Solutions Found:\", str(self.num_solutions))\n\n    ]\n\n    features = [\n        (\"No. of Variables:\", str(self.num_cols)),\n        (\"No. of Integer Variables:\", str(self.num_int)),\n        (\"No. of Constraints\", str(self.num_rows)),\n        (\"No. of Non-zeros in Constr.\", str(self.num_nz))\n    ]\n\n    s = OptimizationSummary(self)\n\n    s.print_generic(header, features)\n\n    print(\"Interventions Chosen:\")\n</code></pre>"},{"location":"base/#minimod_opt.base.basesolver.BaseSolver.write","title":"<code>write(filename='model.lp')</code>","text":"<p>Save model to file</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>name of the file. Defaults to \"model.lp\".</p> <code>'model.lp'</code> Source code in <code>minimod_opt/base/basesolver.py</code> <pre><code>def write(self, filename:str=\"model.lp\"):\n\"\"\"Save model to file\n\n    Args:\n        filename (str, optional):name of the file. Defaults to \"model.lp\".\n    \"\"\"\n\n    self.model.write(filename)\n</code></pre>"},{"location":"base/#minimod_opt.base.bau_constraint.BAUConstraintCreator","title":"<code>BAUConstraintCreator</code>","text":"Source code in <code>minimod_opt/base/bau_constraint.py</code> <pre><code>class BAUConstraintCreator:\n\n    def __init__(self):\n        pass\n\n    def bau_df(self, data:pandas.DataFrame, constraint:str, discounted_variable:str = None) -&gt; pandas.DataFrame:\n\"\"\"A dataframe of costs and benefits for the BAU (business as usual) intervention\n\n        Args:\n            data (pandas.DataFrame): input data\n            constraint (str): name of dataframe BAU column\n            discounted_variable (str, optional): outputs a series of the variable of interest. Defaults to None.\n\n        Returns:\n            pandas.DataFrame\n        \"\"\"\n\n        if discounted_variable is None:\n            discounted_variable = data.columns\n\n        df = (data\n         .loc[(constraint, \n               slice(None), \n               slice(None)),:][discounted_variable]\n         )\n\n        return df\n\n\n    def create_bau_constraint(self, data:pandas.DataFrame, constraint:str, discounted_variable:str, over:str = None)-&gt;pandas.DataFrame:\n\"\"\"This function sums the values of each column in the given dataframe. \n            If the option `over' is provided, the function sums across groups as well\n\n        Args:\n            data (pandas.DataFrame): input data\n            constraint (str): name of dataframe's column with information BAU\n            discounted_variable (str): column of interest.\n            over (str, optional): name of dataframe's column  with attribute used to group data by (e.g., time, region). Defaults to None.\n\n        Returns:\n            pandas.DataFrame: dataframe with the sum of values for each column-group\n        \"\"\"\n\n\n        if over is None:\n            minimum_constraint = (\n                self.bau_df(data, constraint, discounted_variable)\n                .sum()\n            )\n        else:\n            minimum_constraint = (\n                self.bau_df(data, constraint, discounted_variable)\n                .groupby(over)\n                .sum()\n            )\n\n        return minimum_constraint\n</code></pre>"},{"location":"base/#minimod_opt.base.bau_constraint.BAUConstraintCreator.bau_df","title":"<code>bau_df(data, constraint, discounted_variable=None)</code>","text":"<p>A dataframe of costs and benefits for the BAU (business as usual) intervention</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pandas.DataFrame</code> <p>input data</p> required <code>constraint</code> <code>str</code> <p>name of dataframe BAU column</p> required <code>discounted_variable</code> <code>str</code> <p>outputs a series of the variable of interest. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>pandas.DataFrame</p> Source code in <code>minimod_opt/base/bau_constraint.py</code> <pre><code>def bau_df(self, data:pandas.DataFrame, constraint:str, discounted_variable:str = None) -&gt; pandas.DataFrame:\n\"\"\"A dataframe of costs and benefits for the BAU (business as usual) intervention\n\n    Args:\n        data (pandas.DataFrame): input data\n        constraint (str): name of dataframe BAU column\n        discounted_variable (str, optional): outputs a series of the variable of interest. Defaults to None.\n\n    Returns:\n        pandas.DataFrame\n    \"\"\"\n\n    if discounted_variable is None:\n        discounted_variable = data.columns\n\n    df = (data\n     .loc[(constraint, \n           slice(None), \n           slice(None)),:][discounted_variable]\n     )\n\n    return df\n</code></pre>"},{"location":"base/#minimod_opt.base.bau_constraint.BAUConstraintCreator.create_bau_constraint","title":"<code>create_bau_constraint(data, constraint, discounted_variable, over=None)</code>","text":"<p>This function sums the values of each column in the given dataframe.      If the option `over' is provided, the function sums across groups as well</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pandas.DataFrame</code> <p>input data</p> required <code>constraint</code> <code>str</code> <p>name of dataframe's column with information BAU</p> required <code>discounted_variable</code> <code>str</code> <p>column of interest.</p> required <code>over</code> <code>str</code> <p>name of dataframe's column  with attribute used to group data by (e.g., time, region). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>pandas.DataFrame: dataframe with the sum of values for each column-group</p> Source code in <code>minimod_opt/base/bau_constraint.py</code> <pre><code>def create_bau_constraint(self, data:pandas.DataFrame, constraint:str, discounted_variable:str, over:str = None)-&gt;pandas.DataFrame:\n\"\"\"This function sums the values of each column in the given dataframe. \n        If the option `over' is provided, the function sums across groups as well\n\n    Args:\n        data (pandas.DataFrame): input data\n        constraint (str): name of dataframe's column with information BAU\n        discounted_variable (str): column of interest.\n        over (str, optional): name of dataframe's column  with attribute used to group data by (e.g., time, region). Defaults to None.\n\n    Returns:\n        pandas.DataFrame: dataframe with the sum of values for each column-group\n    \"\"\"\n\n\n    if over is None:\n        minimum_constraint = (\n            self.bau_df(data, constraint, discounted_variable)\n            .sum()\n        )\n    else:\n        minimum_constraint = (\n            self.bau_df(data, constraint, discounted_variable)\n            .groupby(over)\n            .sum()\n        )\n\n    return minimum_constraint\n</code></pre>"},{"location":"monte_carlo/","title":"Monte Carlo Classes","text":""},{"location":"monte_carlo/#minimod_opt.monte_carlo.monte_carlo.MonteCarloMinimod","title":"<code>MonteCarloMinimod</code>","text":"Source code in <code>minimod_opt/monte_carlo/monte_carlo.py</code> <pre><code>class MonteCarloMinimod:\n    def __init__(\n        self,\n        solver_type: str=None,\n        data: pd.DataFrame=None,\n        intervention_col: str=None,\n        time_col: str=None,\n        space_col:str=None,\n        benefit_mean_col: str=None,\n        benefit_sd_col: str=None,\n        cost_col: str=None,\n        cost_uniform_perc: float=None,\n        pop_weight_col: str=None,\n        **kwargs,\n    ):\n\"\"\"MonteCarloMinimod uses the `Minimod` optimization classes and conducts Monte Carlo simulations of benefits and cost data through distribution assumptions on the data. Currently the simulations assume a normal distribution about benefits and a uniform distribution around costs.\n\n\n\n        Args:\n            solver_type (str, optional): Whether to minimize costs or maximize benfits. Currently only the former is implemented. Defaults to None.\n            data (pd.DataFrame, optional): The input data. Defaults to None.\n            intervention_col (str, optional): the name of the intervention variable. Defaults to None.\n            time_col (str, optional): the name of the time variable. Defaults to None.\n            space_col (str, optional): the name of region/spatial variable. Defaults to None.\n            benefit_mean_col (str, optional): the name of the variable that gives the mean of benefits for the intervention. Usually just the name of the benefits variable. Defaults to None.\n            benefit_sd_col (str, optional): The name of the variable for the standard deviation of benefits. Defaults to None.\n            cost_col (str, optional): The name of the cost variable. Defaults to None.\n            cost_uniform_perc (float, optional): If using the default of a uniform distribution for costs, the amount of the endpoint of the uniform distribution ([cost*(1+cost_uniform_perc), cost*(1- cost_uniform_perc)]). Defaults to None.\n            pop_weight_col (str, optional): The name name of the variable that specific population weights. Defaults to None.\n\n        Examples:\n\n            Below is an example of how you would run the simulations as well as the visualizations.\n\n            &gt;&gt;&gt; import os; print(os.getcwd())\n            &gt;&gt;&gt; df = (\n            ...     pd.read_csv(\"data/processed/example1.csv\")\n            ...     .assign(benefit_sd = lambda df: df['benefit']/2,\n            ...             costs_sd = lambda df: df['costs']/2)\n            ...     )\n\n            &gt;&gt;&gt; cube = [\"cube\", \"vascube\", \"oilcube\", \"cubemaize\", \"vascubemaize\", \"vasoilcube\", \"oilcubemaize\", \"vasoilcubemaize\"]\n            &gt;&gt;&gt; oil = [\"oil\", \"vasoil\", \"oilcube\", \"oilmaize\", \"vasoilmaize\", \"vasoilcube\", \"oilcubemaize\", \"vasoilcubemaize\"]\n            &gt;&gt;&gt; maize = [\"maize\", \"vasmaize\", \"oilmaize\", \"cubemaize\", \"vascubemaize\", \"vasoilmaize\", \"oilcubemaize\", \"vasoilcubemaize\" ]\n\n            &gt;&gt;&gt; a = mm.MonteCarloMinimod(solver_type = 'costmin', \n            ...                        data = df, \n            ...                        intervention_col='intervention',\n            ...                        space_col='space',\n            ...                        time_col='time',\n            ...                        benefit_mean_col = 'benefit',\n            ...                        benefit_sd_col= 'benefit_sd',\n            ...                        cost_col='costs')\n\n            &gt;&gt;&gt; def benefit_no_change(seed, benefit_col, data):\n            ...    return data[benefit_col]\n\n            &gt;&gt;&gt; sim = a.fit_all_samples(N = 100, \n            ...                         all_space=oil, \n            ...                         all_time=cube, \n            ...                         time_subset=[1,2,3], \n            ...                         minimum_benefit='vasoilold', \n            ...                         benefit_callable=benefit_no_change, \n            ...                         benefit_kwargs={'benefit_col' : 'benefit'}\n            ...                         )\n\n            &gt;&gt;&gt; a.plot_opt_hist(save = \"sim_results.png\")\n\n            &gt;&gt;&gt; a.report(perc_intervention_appeared=True)\n\n            &gt;&gt;&gt; a.plot_sim_trajectories(save = 'sim_traj.png')\n\n        \"\"\"        \n\n\n        print(\"\"\"Monte Carlo Simulator\"\"\")\n\n        self.solver_type = solver_type\n\n        self.data = data.set_index([intervention_col, space_col, time_col])\n\n        self.intervention_col = intervention_col\n        self.space_col = space_col\n        self.time_col = time_col\n\n        if pop_weight_col is None:\n            self.data = self.data.assign(pop_weight_col=1)\n            self.pop_weight_col = \"pop_weight_col\"\n        else:\n            self.pop_weight_col = pop_weight_col\n\n        self.benefit_mean_col = benefit_mean_col\n        self.benefit_sd_col = benefit_sd_col\n\n        if cost_uniform_perc is None:\n            self.cost_uniform_perc = 0.2\n        else:\n            self.cost_uniform_perc = cost_uniform_perc\n\n        self.cost_col = cost_col\n\n\n    def _construct_benefit_sample(self, seed: int, data: pd.DataFrame=None, benefit_col: str = 'benefit_random_draw') -&gt; pd.Series:\n\"\"\"Draw of a sample of benefits assuming normality\n\n        Args:\n            seed (int): The random seed\n            data (pd.DataFrame, optional): The input data. Defaults to None.\n            benefit_col (str, optional): the name of the resulting benefits variable. Defaults to 'benefit_random_draw'.\n\n        Returns:\n            pd.Series: A series of benefits\n        \"\"\"        \n\n        random = np.random.default_rng(seed=seed)\n\n        df_mean_sd = data[\n            [self.benefit_mean_col, self.benefit_sd_col, self.pop_weight_col]\n        ]\n\n        df = df_mean_sd.pipe(self._drop_nan_benefits).assign(\n            weight_mean=lambda df: df[self.benefit_mean_col] * df[self.pop_weight_col],\n            weight_sd=lambda df: df[self.benefit_sd_col] * df[self.pop_weight_col],\n            benefit_random_draw=lambda df: random.normal(\n                df[\"weight_mean\"], df[\"weight_sd\"]\n            ),\n        )\n\n        return df[benefit_col]\n\n    def _construct_cost_sample(self, seed: str, data: pd.DataFrame=None, cost_col: str='cost_random_draw') -&gt; pd.Series:\n\"\"\"Draw a sample costs assuming a uniform distribution\n\n        Args:\n            seed (str): The randome\n            data (pd.DataFrame, optional): The input data. Defaults to None.\n            cost_col (str, optional): The name of the cost variable. Defaults to 'cost_random_draw'.\n\n        Returns:\n            pd.Series: The cost draw\n        \"\"\"        \n\n        random= np.random.default_rng(seed=seed)\n\n        df_costs = data[self.cost_col]\n        df_costs_low = (1 - self.cost_uniform_perc) * data[self.cost_col]\n        df_costs_high = (1 + self.cost_uniform_perc) * data[self.cost_col]\n\n        df = df_costs.to_frame().assign(\n            cost_random_draw=random.uniform(df_costs_low, df_costs_high)\n        )\n\n        return df[cost_col]\n\n    def _drop_nan_benefits(self, data):\n\n        df = data.dropna(subset=[self.benefit_sd_col])\n\n        return df\n\n    def _merge_samples(self, benefit_callable: Callable, cost_callable: Callable,  \n                       cost_kwargs: dict, benefit_kwargs: dict) -&gt; pd.DataFrame:\n\"\"\"Transforms the cost and benefit data and merges them together.\n\n        Args:\n            benefit_callable (Callable): The function for transforming benefits\n            cost_callable (Callable): The function for transforming costs\n            cost_kwargs (dict): extra arguments for `cost_callable`\n            benefit_kwargs (dict): extra arguments for `benefit_callable`\n\n        Returns:\n            pd.DataFrame: The merged dataset of benefits and costs\n        \"\"\"        \n\n\n        benefit_sample = benefit_callable(**benefit_kwargs)\n        cost_sample = cost_callable(**cost_kwargs)\n\n        return benefit_sample.to_frame().merge(\n            cost_sample, left_index=True, right_index=True\n        )\n\n    def fit_one_sample(self, \n                       seed: int,\n                       all_space: Union[List, None],\n                       all_time: Union[List, None],\n                       space_subset: List[str],\n                       time_subset: List[int],\n                       strict: bool,\n                       benefit_callable:Union[Callable, None],\n                       cost_callable:Union[Callable, None],\n                       cost_kwargs:dict,\n                       benefit_kwargs:dict,\n                       **kwargs) -&gt; dict:\n\"\"\"Draw one MonteCarlo sample and optimize. To be used with `fit_all_samples`. \n\n        `benefit_callable` and `cost_callable` must be functions with arguments `(seed, benefit_col, data)`. `cost_kwargs` and `benefit_kwargs` can be input to override defaults, such as if you want to use a different seed or change the name of a column.\n\n        Note: `benefit_col` and `cost_col` for these callables denote the name of the resulting columns of the draw, not the original variable names.\n\n        Args:\n            seed (int): random seed\n            all_space (Union[List, None]): spatial constraints (as in `Minimod`)\n            all_time (Union[List, None]): time constraints (as in `Minimod`)\n            space_subset (List[str]): subset for space constraints (as in `Minimod`)\n            time_subset (List[int]): subset for time constraints (as in `Minimod`)\n            strict (bool): whether to treat list of intervention names input *strictly* or using regex\n            benefit_callable (Union[Callable, None]): The function for benefits transformation\n            cost_callable (Union[Callable, None]): The function for cost transformation\n            cost_kwargs (dict): extra arguments for the cost_callabe\n            benefit_kwargs (dict): extra arguments for benefits callable\n\n        Returns:\n            dict: A dictionary of fitted results\n        \"\"\"    \n\n        if benefit_callable is None:\n            benefit_callable = self._construct_benefit_sample\n        if cost_callable is None:\n            cost_callable = self._construct_cost_sample\n\n        cost_kwargs_default = {'seed' : seed, 'cost_col' : 'cost_random_draw', 'data' : self.data}\n        benefit_kwargs_default = {'seed' : seed, 'benefit_col' : 'benefit_random_draw', 'data' : self.data}\n\n        if cost_kwargs is not None:\n            cost_kwargs_default.update(cost_kwargs)\n        if benefit_kwargs is not None:\n            benefit_kwargs_default.update(benefit_kwargs)\n\n\n        df = self._merge_samples(benefit_callable=benefit_callable,\n                                 cost_callable=cost_callable,\n                                 benefit_kwargs=benefit_kwargs_default,\n                                 cost_kwargs=cost_kwargs_default) \n\n        minimod = Minimod(solver_type=self.solver_type)(\n            data=df,\n            intervention_col=self.intervention_col,\n            space_col=self.space_col,\n            time_col=self.time_col,\n            benefit_col=benefit_kwargs_default.get('benefit_col'),\n            cost_col=cost_kwargs_default.get('cost_col'),\n            all_space=all_space,\n            all_time=all_time,\n            space_subset=space_subset,\n            time_subset=time_subset,\n            show_output=False,\n            strict=strict,\n            benefit_title=\"Effective Coverage\",\n            **kwargs,\n        )\n\n        minimod_opt.fit()\n\n        # Run `minimod_opt.report` to get opt_df for iteration\n        # Also save the opt_chosen dataframes in case there are multiple solutions\n\n        opt_df_list = []\n\n        for i in range(minimod_opt.num_solutions):\n            minimod_opt.report(sol_num=i, quiet=True)\n            opt_df_list.append(minimod_opt.opt_df)\n\n        #TODO: add lowest cost per life saved index into iteration dict\n\n        iteration_dict = {\n            \"status\": minimod_opt.status,\n            \"opt_objective\": [df['opt_costs_discounted'].sum() for df in opt_df_list],\n            \"opt_constraint\": [df[\"opt_benefit_discounted\"].sum() for df in opt_df_list],\n            \"num_vars\": minimod_opt.num_cols,\n            \"constraints\": minimod_opt.num_rows,\n            \"solutions\": minimod_opt.num_solutions,\n            \"num_int\": minimod_opt.num_int,\n            \"num_nz\": minimod_opt.num_nz,\n            \"opt_df\": opt_df_list,\n            \"sense\" : minimod_opt.sense,\n            \"solver_name\" : minimod_opt.solver_name,\n            \"minimum_benefit\" : minimod_opt.minimum_benefit,\n            \"benefit_title\" : minimod_opt.benefit_title,\n            \"bau_draw\" : minimod_opt.bau_df\n        }\n\n        return iteration_dict\n\n    def fit_all_samples(\n        self,\n        n_jobs = 5,\n        N=None,\n        all_space=None,\n        all_time=None,\n        space_subset=None,\n        time_subset=None,\n        strict=False,\n        exception_behavior = 'immediate',\n        only_optimal=False,\n        benefit_callable=None,\n        cost_callable=None,\n        benefit_kwargs=None,\n        cost_kwargs=None,\n        random_seeds = None,\n        **kwargs\n    ):\n\n        if N is None:\n            N = 10\n\n        sim_dict = {}\n\n\n        print(f\"\"\"Running with {N} Samples\"\"\")\n\n        partial_fit_sample = partial(self.fit_one_sample, \n                                     all_space=all_space,\n                                     all_time=all_time,\n                                     space_subset=space_subset,\n                                     time_subset = time_subset,\n                                     strict=strict,\n                                     benefit_callable=benefit_callable,\n                                     cost_callable=cost_callable,\n                                     benefit_kwargs=benefit_kwargs,\n                                     cost_kwargs=cost_kwargs,\n                                     **kwargs)\n\n        if random_seeds is None:\n            random_seeds = range(N)\n\n        sim_dict = pqdm(random_seeds, partial_fit_sample, n_jobs=n_jobs, exception_behaviour=exception_behavior)\n\n        sim_df = pd.DataFrame(sim_dict)\n\n        self.perc_opt = sim_df[\"status\"].value_counts(normalize=True)[0] * 100\n\n        if only_optimal:\n            self.sim_results = sim_df.loc[lambda df: df['status'] == OptimizationStatus.OPTIMAL]\n        else:\n            self.sim_results = sim_df\n\n        self.N = self.sim_results.shape[0]\n\n        return self.sim_results\n\n    def _all_opt_df(self, sol_filter=None):\n\"\"\"Appends the dataframe from all simulation iterations together\n        \"\"\"\n        #TODO: #28 Allow for concatenation of a combination of solutions, or all\n\n        # First get sim_results so that `opt_df` is a series of dataframes\n        # Turn list into numpy since it has a `take` method\n\n        if sol_filter=='min_cb':\n            # Find the solution with the highest benefit/cost ratio\n            sol_num_all_opt_df = self.sim_results.assign(best_solution  = lambda df: df.apply(lambda df: (np.array(df['opt_objective'])/np.array(df['opt_constraint'])).argmin(), axis=1),\n                                       new_opt_df = lambda df: df.apply(lambda x: x['opt_df'][x['best_solution']], axis=1))\n        else:\n            sol_num_all_opt_df = self.sim_results.assign(new_opt_df = lambda df: df['opt_df'].apply(lambda x: pd.concat(x)))\n\n        all_opt_df = pd.concat(sol_num_all_opt_df.apply(lambda x: x['new_opt_df'].assign(iteration = x.name), axis=1).tolist())\n\n        return all_opt_df\n\n    def _get_intervention_group(self, data, intervention, strict=False):\n\n\n        if strict:\n\n            int_group = (\n                data\n                .loc[lambda df: df.index.\n                    get_level_values(level= self.intervention_col)\n                    .isin(intervention)]\n            )\n\n        else:\n            int_group = (\n                data\n                .loc[lambda df: df.index.\n                    get_level_values(level= self.intervention_col)\n                    .str.contains(intervention)]\n            )\n\n        return int_group\n\n    def _get_indicator_if_in_intervention(self, name, indicator_spec = None, strict=False):\n\n        if indicator_spec is None:\n            indicator_spec = 1\n\n        return (self._get_intervention_group(self._all_opt_df(), name, strict=strict)\n                .reset_index()\n                [['opt_vals', 'iteration', self.intervention_col, self.space_col, self.time_col]]\n                .groupby('iteration')\n                .agg(lambda x: 1 if x.sum() &gt; indicator_spec else 0)\n                )\n\n    def report(\n        self,\n        avg_time=False,\n        avg_space=False,\n        intervention_group=None,\n        indicator_spec = None,\n        strict=False\n    ):\n\n        avg = self.sim_results.convert_dtypes().mean()\n\n        s = OptimizationSummary(self)\n\n        header = [\n            (\"MiniMod Solver Results\", \"\"),\n            (\"Method:\", str(self.sim_results['sense'].min())),\n            (\"Solver:\", str(self.sim_results['solver_name'].min())),\n            (\"Percentage Optimized:\", self.perc_opt),\n            (\"Average Number Solutions Found:\", avg[\"solutions\"]),\n        ]\n\n        features = [\n            (\"No. of Variables:\", avg[\"num_vars\"]),\n            (\"No. of Integer Variables:\", avg[\"num_int\"]),\n            (\"No. of Constraints\", avg[\"constraints\"]),\n            (\"No. of Non-zeros in Constr.\", avg[\"num_nz\"]),\n        ]\n\n        results_benefits = [(\"Minimum Benefit\", self.sim_results.minimum_benefit.mean())]\n\n        stats = [\n            (\"Statistics for Benefits and Costs\", \"\"),\n        ]\n\n        s.print_generic(header, features, results_benefits, stats)\n\n        stats_df = (\n            self.sim_results[[\"opt_objective\", \"opt_constraint\"]]\n            .astype(float)\n            .describe()\n            .round(4)\n            .to_markdown()\n        )\n        print(stats_df)\n\n        if intervention_group is not None:\n\n            s.print_generic([(f\"% Appearance of:\", \"\")])\n\n            for i in intervention_group:\n\n                int_group = (self._get_indicator_if_in_intervention(i, \n                                                                    indicator_spec=indicator_spec,\n                                                                    strict=strict).sum()/self.N*100)['opt_vals']\n\n                s.print_generic([(f\"{i}\", f\"{int_group}\")])\n\n        if avg_time:\n\n            time_df = (\n                self._all_opt_df().groupby([self.time_col, \"iteration\"])\n                .sum()\n                .groupby(self.time_col)\n                .mean()[[\"opt_benefit\", \"opt_costs\"]]\n            )\n\n            s.print_generic([(\"Mean Benefits and Costs across time\", \"\")])\n            print(time_df.to_markdown())\n\n        if avg_space:\n\n            space_df = (\n                self._all_opt_df().groupby([self.space_col, \"iteration\"])\n                .sum()\n                .groupby(self.space_col)\n                .mean()[[\"opt_benefit\", \"opt_costs\"]]\n            )\n\n            s.print_generic([(\"Mean Benefits and Costs across Regions\", \"\")])\n            print(space_df.to_markdown())\n\n    def plot_opt_hist(self, save=None):\n\n        p = Plotter(self)\n\n        costs = \"Optimal Costs\"\n        benefits = self.sim_results['benefit_title'].min()\n\n        if self.solver_type == \"costmin\":\n\n            objective_title = costs\n            constraint_title = benefits\n\n        elif self.solver_type == \"benmax\":\n\n            objective_title = benefits\n            constraint_title = costs\n\n\n        self.sim_results['opt_constraint2']=self.sim_results['opt_constraint'].apply(lambda x: x[0]/1000)\n        self.sim_results['opt_objective2']=self.sim_results['opt_objective'].apply(lambda x: x[0]/1000)\n\n        fig, (benefit_plot, cost_plot) = p._plot_sim_hist(\n            data=self.sim_results,\n            benefit_col=\"opt_constraint2\",\n            cost_col=\"opt_objective2\",\n            #benefit_col=\"opt_constraint\",\n            #cost_col=\"opt_objective\",\n            cost_title=objective_title,\n            benefit_title=constraint_title,\n            save=save,\n        )\n\n        benefit_plot.xaxis.set_major_formatter(mtick.StrMethodFormatter('{x:,.0f}'))\n        cost_plot.xaxis.set_major_formatter(mtick.StrMethodFormatter('{x:,.0f}'))\n\n        benefit_plot.set_xlabel(\"Thousands of Individuals\")\n        cost_plot.set_xlabel(\"Thousands of 2019 USD\")\n\n        benefit_xlims = benefit_plot.get_xlim()\n        benefit_ylims = benefit_plot.get_ylim()\n\n        # Put text at midpoint of y\n        text_y = (benefit_ylims[1] - benefit_ylims[0]) / 2\n\n        # offset by 10% of length of x-axis\n        text_x = (\n            self.sim_results['minimum_benefit'].mean()/1000 + (benefit_xlims[1] - benefit_xlims[0]) * 0.1\n        )\n\n        benefit_plot.axvline(self.sim_results['minimum_benefit'].mean()/1000, color=\"red\")\n        benefit_plot.text(text_x, text_y, \"Mean\\nMinimum\\nBenefit\\nConstraint\")\n\n        # Get total cost for a draw \n        cost_xlims = cost_plot.get_xlim()\n        cost_ylims = cost_plot.get_ylim()\n\n        # Put text at midpoint of y\n        cost_plot.axvline(self.sim_results['bau_draw'].apply(lambda x: x['discounted_costs'].sum()).mean()/1000, color='red')\n\n        text_y2 = (cost_ylims[1] - cost_ylims[0]) / 2\n\n        # offset by 10% of length of x-axis\n        text_x2 = (\n            self.sim_results['bau_draw'].apply(lambda x: x['discounted_costs'].sum()).mean()/1000 + (cost_xlims[1] - cost_xlims[0]) * 0.1\n        )\n        cost_plot.text(text_x2, text_y2, \"Mean\\nBAU\\nCost\")\n\n        return fig, (benefit_plot, cost_plot)\n\n    def plot_sim_trajectories(self, data_of_interest=\"benefits\", save=None):\n\n        fig, ax = plt.subplots()\n\n        if data_of_interest == \"benefits\":\n            col_of_interest = \"opt_benefit\"\n            ylabel_interest = \"Individuals\"\n        elif data_of_interest == \"costs\":\n            col_of_interest = \"opt_costs\"\n            ylabel_interest = \"2019 USD\"\n\n        df_all = self.sim_results['opt_df'].apply(lambda x: x[col_of_interest].groupby(self.time_col).sum()).T\n\n        # Now get mean trajectory\n\n        df_all.plot(color='red', alpha=0.09, ax=ax, legend=False)\n        df_all.mean(axis=1).plot(ax=ax, color=\"black\")\n\n        # plt.figtext(0, 0, \"Bold line represents mean trajectory.\")\n        ax.set_title(\"Trajectories of all Simulations\")\n\n        ax.yaxis.set_major_formatter(mtick.StrMethodFormatter('{x:,.0f}'))\n        ax.set_ylabel(ylabel_interest)\n\n        if save is not None:\n            plt.savefig(save, dpi=160)\n\n        return ax\n\n    def plot_intervention_stacked(self, intervention_group=None, intervention_names = None, indicator_spec=3):\n\n        fig, ax = plt.subplots()\n\n        all_opt_df = (self._all_opt_df()\n                      .groupby(['intervention', 'time', 'iteration'])\n                      ['opt_vals']\n                      .sum()\n                      .to_frame()\n                      .assign(opt_vals = lambda df: (df['opt_vals']&gt;indicator_spec).astype(int))\n                      )\n\n        int_group = (\n            all_opt_df[all_opt_df['opt_vals']&gt;indicator_spec]\n            .reset_index(level=self.intervention_col)\n            [self.intervention_col]\n            .str.extractall('|'.join([f\"(?P&lt;{j}&gt;{i})\" for i, j in zip(intervention_group, intervention_names)]))\n         )             \n\n        int_group.groupby(self.time_col).count().apply(lambda x: x/x.sum(), axis=1).plot.bar(stacked=True, ax=ax)\n\n\n        ax.legend(loc = 'lower left', bbox_to_anchor=(1.0, 0.5))\n        ax.set_ylabel(\"% of Occurrences\")\n        ax.set_xlabel(\"Time\")\n\n        return ax\n</code></pre>"},{"location":"monte_carlo/#minimod_opt.monte_carlo.monte_carlo.MonteCarloMinimod.__init__","title":"<code>__init__(solver_type=None, data=None, intervention_col=None, time_col=None, space_col=None, benefit_mean_col=None, benefit_sd_col=None, cost_col=None, cost_uniform_perc=None, pop_weight_col=None, **kwargs)</code>","text":"<p>MonteCarloMinimod uses the <code>Minimod</code> optimization classes and conducts Monte Carlo simulations of benefits and cost data through distribution assumptions on the data. Currently the simulations assume a normal distribution about benefits and a uniform distribution around costs.</p> <p>Parameters:</p> Name Type Description Default <code>solver_type</code> <code>str</code> <p>Whether to minimize costs or maximize benfits. Currently only the former is implemented. Defaults to None.</p> <code>None</code> <code>data</code> <code>pd.DataFrame</code> <p>The input data. Defaults to None.</p> <code>None</code> <code>intervention_col</code> <code>str</code> <p>the name of the intervention variable. Defaults to None.</p> <code>None</code> <code>time_col</code> <code>str</code> <p>the name of the time variable. Defaults to None.</p> <code>None</code> <code>space_col</code> <code>str</code> <p>the name of region/spatial variable. Defaults to None.</p> <code>None</code> <code>benefit_mean_col</code> <code>str</code> <p>the name of the variable that gives the mean of benefits for the intervention. Usually just the name of the benefits variable. Defaults to None.</p> <code>None</code> <code>benefit_sd_col</code> <code>str</code> <p>The name of the variable for the standard deviation of benefits. Defaults to None.</p> <code>None</code> <code>cost_col</code> <code>str</code> <p>The name of the cost variable. Defaults to None.</p> <code>None</code> <code>cost_uniform_perc</code> <code>float</code> <p>If using the default of a uniform distribution for costs, the amount of the endpoint of the uniform distribution ([cost(1+cost_uniform_perc), cost(1- cost_uniform_perc)]). Defaults to None.</p> <code>None</code> <code>pop_weight_col</code> <code>str</code> <p>The name name of the variable that specific population weights. Defaults to None.</p> <code>None</code> <p>Examples:</p> <p>Below is an example of how you would run the simulations as well as the visualizations.</p> <pre><code>&gt;&gt;&gt; import os; print(os.getcwd())\n&gt;&gt;&gt; df = (\n...     pd.read_csv(\"data/processed/example1.csv\")\n...     .assign(benefit_sd = lambda df: df['benefit']/2,\n...             costs_sd = lambda df: df['costs']/2)\n...     )\n</code></pre> <pre><code>&gt;&gt;&gt; cube = [\"cube\", \"vascube\", \"oilcube\", \"cubemaize\", \"vascubemaize\", \"vasoilcube\", \"oilcubemaize\", \"vasoilcubemaize\"]\n&gt;&gt;&gt; oil = [\"oil\", \"vasoil\", \"oilcube\", \"oilmaize\", \"vasoilmaize\", \"vasoilcube\", \"oilcubemaize\", \"vasoilcubemaize\"]\n&gt;&gt;&gt; maize = [\"maize\", \"vasmaize\", \"oilmaize\", \"cubemaize\", \"vascubemaize\", \"vasoilmaize\", \"oilcubemaize\", \"vasoilcubemaize\" ]\n</code></pre> <pre><code>&gt;&gt;&gt; a = mm.MonteCarloMinimod(solver_type = 'costmin', \n...                        data = df, \n...                        intervention_col='intervention',\n...                        space_col='space',\n...                        time_col='time',\n...                        benefit_mean_col = 'benefit',\n...                        benefit_sd_col= 'benefit_sd',\n...                        cost_col='costs')\n</code></pre> <pre><code>&gt;&gt;&gt; def benefit_no_change(seed, benefit_col, data):\n...    return data[benefit_col]\n</code></pre> <pre><code>&gt;&gt;&gt; sim = a.fit_all_samples(N = 100, \n...                         all_space=oil, \n...                         all_time=cube, \n...                         time_subset=[1,2,3], \n...                         minimum_benefit='vasoilold', \n...                         benefit_callable=benefit_no_change, \n...                         benefit_kwargs={'benefit_col' : 'benefit'}\n...                         )\n</code></pre> <pre><code>&gt;&gt;&gt; a.plot_opt_hist(save = \"sim_results.png\")\n</code></pre> <pre><code>&gt;&gt;&gt; a.report(perc_intervention_appeared=True)\n</code></pre> <pre><code>&gt;&gt;&gt; a.plot_sim_trajectories(save = 'sim_traj.png')\n</code></pre> Source code in <code>minimod_opt/monte_carlo/monte_carlo.py</code> <pre><code>def __init__(\n    self,\n    solver_type: str=None,\n    data: pd.DataFrame=None,\n    intervention_col: str=None,\n    time_col: str=None,\n    space_col:str=None,\n    benefit_mean_col: str=None,\n    benefit_sd_col: str=None,\n    cost_col: str=None,\n    cost_uniform_perc: float=None,\n    pop_weight_col: str=None,\n    **kwargs,\n):\n\"\"\"MonteCarloMinimod uses the `Minimod` optimization classes and conducts Monte Carlo simulations of benefits and cost data through distribution assumptions on the data. Currently the simulations assume a normal distribution about benefits and a uniform distribution around costs.\n\n\n\n    Args:\n        solver_type (str, optional): Whether to minimize costs or maximize benfits. Currently only the former is implemented. Defaults to None.\n        data (pd.DataFrame, optional): The input data. Defaults to None.\n        intervention_col (str, optional): the name of the intervention variable. Defaults to None.\n        time_col (str, optional): the name of the time variable. Defaults to None.\n        space_col (str, optional): the name of region/spatial variable. Defaults to None.\n        benefit_mean_col (str, optional): the name of the variable that gives the mean of benefits for the intervention. Usually just the name of the benefits variable. Defaults to None.\n        benefit_sd_col (str, optional): The name of the variable for the standard deviation of benefits. Defaults to None.\n        cost_col (str, optional): The name of the cost variable. Defaults to None.\n        cost_uniform_perc (float, optional): If using the default of a uniform distribution for costs, the amount of the endpoint of the uniform distribution ([cost*(1+cost_uniform_perc), cost*(1- cost_uniform_perc)]). Defaults to None.\n        pop_weight_col (str, optional): The name name of the variable that specific population weights. Defaults to None.\n\n    Examples:\n\n        Below is an example of how you would run the simulations as well as the visualizations.\n\n        &gt;&gt;&gt; import os; print(os.getcwd())\n        &gt;&gt;&gt; df = (\n        ...     pd.read_csv(\"data/processed/example1.csv\")\n        ...     .assign(benefit_sd = lambda df: df['benefit']/2,\n        ...             costs_sd = lambda df: df['costs']/2)\n        ...     )\n\n        &gt;&gt;&gt; cube = [\"cube\", \"vascube\", \"oilcube\", \"cubemaize\", \"vascubemaize\", \"vasoilcube\", \"oilcubemaize\", \"vasoilcubemaize\"]\n        &gt;&gt;&gt; oil = [\"oil\", \"vasoil\", \"oilcube\", \"oilmaize\", \"vasoilmaize\", \"vasoilcube\", \"oilcubemaize\", \"vasoilcubemaize\"]\n        &gt;&gt;&gt; maize = [\"maize\", \"vasmaize\", \"oilmaize\", \"cubemaize\", \"vascubemaize\", \"vasoilmaize\", \"oilcubemaize\", \"vasoilcubemaize\" ]\n\n        &gt;&gt;&gt; a = mm.MonteCarloMinimod(solver_type = 'costmin', \n        ...                        data = df, \n        ...                        intervention_col='intervention',\n        ...                        space_col='space',\n        ...                        time_col='time',\n        ...                        benefit_mean_col = 'benefit',\n        ...                        benefit_sd_col= 'benefit_sd',\n        ...                        cost_col='costs')\n\n        &gt;&gt;&gt; def benefit_no_change(seed, benefit_col, data):\n        ...    return data[benefit_col]\n\n        &gt;&gt;&gt; sim = a.fit_all_samples(N = 100, \n        ...                         all_space=oil, \n        ...                         all_time=cube, \n        ...                         time_subset=[1,2,3], \n        ...                         minimum_benefit='vasoilold', \n        ...                         benefit_callable=benefit_no_change, \n        ...                         benefit_kwargs={'benefit_col' : 'benefit'}\n        ...                         )\n\n        &gt;&gt;&gt; a.plot_opt_hist(save = \"sim_results.png\")\n\n        &gt;&gt;&gt; a.report(perc_intervention_appeared=True)\n\n        &gt;&gt;&gt; a.plot_sim_trajectories(save = 'sim_traj.png')\n\n    \"\"\"        \n\n\n    print(\"\"\"Monte Carlo Simulator\"\"\")\n\n    self.solver_type = solver_type\n\n    self.data = data.set_index([intervention_col, space_col, time_col])\n\n    self.intervention_col = intervention_col\n    self.space_col = space_col\n    self.time_col = time_col\n\n    if pop_weight_col is None:\n        self.data = self.data.assign(pop_weight_col=1)\n        self.pop_weight_col = \"pop_weight_col\"\n    else:\n        self.pop_weight_col = pop_weight_col\n\n    self.benefit_mean_col = benefit_mean_col\n    self.benefit_sd_col = benefit_sd_col\n\n    if cost_uniform_perc is None:\n        self.cost_uniform_perc = 0.2\n    else:\n        self.cost_uniform_perc = cost_uniform_perc\n\n    self.cost_col = cost_col\n</code></pre>"},{"location":"monte_carlo/#minimod_opt.monte_carlo.monte_carlo.MonteCarloMinimod.fit_one_sample","title":"<code>fit_one_sample(seed, all_space, all_time, space_subset, time_subset, strict, benefit_callable, cost_callable, cost_kwargs, benefit_kwargs, **kwargs)</code>","text":"<p>Draw one MonteCarlo sample and optimize. To be used with <code>fit_all_samples</code>. </p> <p><code>benefit_callable</code> and <code>cost_callable</code> must be functions with arguments <code>(seed, benefit_col, data)</code>. <code>cost_kwargs</code> and <code>benefit_kwargs</code> can be input to override defaults, such as if you want to use a different seed or change the name of a column.</p> <p>Note: <code>benefit_col</code> and <code>cost_col</code> for these callables denote the name of the resulting columns of the draw, not the original variable names.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>random seed</p> required <code>all_space</code> <code>Union[List, None]</code> <p>spatial constraints (as in <code>Minimod</code>)</p> required <code>all_time</code> <code>Union[List, None]</code> <p>time constraints (as in <code>Minimod</code>)</p> required <code>space_subset</code> <code>List[str]</code> <p>subset for space constraints (as in <code>Minimod</code>)</p> required <code>time_subset</code> <code>List[int]</code> <p>subset for time constraints (as in <code>Minimod</code>)</p> required <code>strict</code> <code>bool</code> <p>whether to treat list of intervention names input strictly or using regex</p> required <code>benefit_callable</code> <code>Union[Callable, None]</code> <p>The function for benefits transformation</p> required <code>cost_callable</code> <code>Union[Callable, None]</code> <p>The function for cost transformation</p> required <code>cost_kwargs</code> <code>dict</code> <p>extra arguments for the cost_callabe</p> required <code>benefit_kwargs</code> <code>dict</code> <p>extra arguments for benefits callable</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary of fitted results</p> Source code in <code>minimod_opt/monte_carlo/monte_carlo.py</code> <pre><code>def fit_one_sample(self, \n                   seed: int,\n                   all_space: Union[List, None],\n                   all_time: Union[List, None],\n                   space_subset: List[str],\n                   time_subset: List[int],\n                   strict: bool,\n                   benefit_callable:Union[Callable, None],\n                   cost_callable:Union[Callable, None],\n                   cost_kwargs:dict,\n                   benefit_kwargs:dict,\n                   **kwargs) -&gt; dict:\n\"\"\"Draw one MonteCarlo sample and optimize. To be used with `fit_all_samples`. \n\n    `benefit_callable` and `cost_callable` must be functions with arguments `(seed, benefit_col, data)`. `cost_kwargs` and `benefit_kwargs` can be input to override defaults, such as if you want to use a different seed or change the name of a column.\n\n    Note: `benefit_col` and `cost_col` for these callables denote the name of the resulting columns of the draw, not the original variable names.\n\n    Args:\n        seed (int): random seed\n        all_space (Union[List, None]): spatial constraints (as in `Minimod`)\n        all_time (Union[List, None]): time constraints (as in `Minimod`)\n        space_subset (List[str]): subset for space constraints (as in `Minimod`)\n        time_subset (List[int]): subset for time constraints (as in `Minimod`)\n        strict (bool): whether to treat list of intervention names input *strictly* or using regex\n        benefit_callable (Union[Callable, None]): The function for benefits transformation\n        cost_callable (Union[Callable, None]): The function for cost transformation\n        cost_kwargs (dict): extra arguments for the cost_callabe\n        benefit_kwargs (dict): extra arguments for benefits callable\n\n    Returns:\n        dict: A dictionary of fitted results\n    \"\"\"    \n\n    if benefit_callable is None:\n        benefit_callable = self._construct_benefit_sample\n    if cost_callable is None:\n        cost_callable = self._construct_cost_sample\n\n    cost_kwargs_default = {'seed' : seed, 'cost_col' : 'cost_random_draw', 'data' : self.data}\n    benefit_kwargs_default = {'seed' : seed, 'benefit_col' : 'benefit_random_draw', 'data' : self.data}\n\n    if cost_kwargs is not None:\n        cost_kwargs_default.update(cost_kwargs)\n    if benefit_kwargs is not None:\n        benefit_kwargs_default.update(benefit_kwargs)\n\n\n    df = self._merge_samples(benefit_callable=benefit_callable,\n                             cost_callable=cost_callable,\n                             benefit_kwargs=benefit_kwargs_default,\n                             cost_kwargs=cost_kwargs_default) \n\n    minimod = Minimod(solver_type=self.solver_type)(\n        data=df,\n        intervention_col=self.intervention_col,\n        space_col=self.space_col,\n        time_col=self.time_col,\n        benefit_col=benefit_kwargs_default.get('benefit_col'),\n        cost_col=cost_kwargs_default.get('cost_col'),\n        all_space=all_space,\n        all_time=all_time,\n        space_subset=space_subset,\n        time_subset=time_subset,\n        show_output=False,\n        strict=strict,\n        benefit_title=\"Effective Coverage\",\n        **kwargs,\n    )\n\n    minimod_opt.fit()\n\n    # Run `minimod_opt.report` to get opt_df for iteration\n    # Also save the opt_chosen dataframes in case there are multiple solutions\n\n    opt_df_list = []\n\n    for i in range(minimod_opt.num_solutions):\n        minimod_opt.report(sol_num=i, quiet=True)\n        opt_df_list.append(minimod_opt.opt_df)\n\n    #TODO: add lowest cost per life saved index into iteration dict\n\n    iteration_dict = {\n        \"status\": minimod_opt.status,\n        \"opt_objective\": [df['opt_costs_discounted'].sum() for df in opt_df_list],\n        \"opt_constraint\": [df[\"opt_benefit_discounted\"].sum() for df in opt_df_list],\n        \"num_vars\": minimod_opt.num_cols,\n        \"constraints\": minimod_opt.num_rows,\n        \"solutions\": minimod_opt.num_solutions,\n        \"num_int\": minimod_opt.num_int,\n        \"num_nz\": minimod_opt.num_nz,\n        \"opt_df\": opt_df_list,\n        \"sense\" : minimod_opt.sense,\n        \"solver_name\" : minimod_opt.solver_name,\n        \"minimum_benefit\" : minimod_opt.minimum_benefit,\n        \"benefit_title\" : minimod_opt.benefit_title,\n        \"bau_draw\" : minimod_opt.bau_df\n    }\n\n    return iteration_dict\n</code></pre>"},{"location":"solvers/","title":"Solver Classes","text":""},{"location":"utils/","title":"Utility Classes","text":""}]}